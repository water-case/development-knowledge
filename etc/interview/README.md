# **기술 면접 빈출 질문**

### 참고자료

- [CS study Repo](https://github.com/SSAFY-CS-STUDY/Tech_interview)

## 목차
>- [Java](#java)
>- [Operating System](#operating-system)
>- [Network](#network)
>- [Database](#database)


<br>

---

## Java

>### Java문제
>[[답변]](#java답변)
>- 객체지향 프로그래밍과 절차지향 프로그래밍의 차이에 대해 설명하시오
>- 객체지향 프로그래밍의 특징에 대해 설명하시오
>- 객체지향 설계 5원칙에 대해 설명하시오
>- 오버로딩과 오버라이딩에 대해 설명하시오
>- 클래스와 객체의 차이를 설명하시오
>- 객체와 인스턴스의 차이를 설명하시오
>- 자바의 특징에 대해 설명하시오
>- Java SE와 EE의 차이를 설명하시오
>- 참조형 변수와 기본형 변수의 차이를 설명하시오
>- 변수의 3가지 타입에 대해 설명하시오
>- Wrapper Class에 대해 설명하시오
>- public 접근 제어자와 private 접근 제어자의 차이를 설명하시오
>- Boxing, Unboxing에 대해 설명하시오
>- non-static 멤버와 static 멤버의 차이를 설명하시오
>- main 메서드가 public static 인 이유를 설명하시오
>- final 키워드의 용도에 대해 설명하시오
>- Generic에 대해 설명하시오
>- ==과 equals()의 차이를 설명하시오
>- Call by Reference와 Call by Value에 대해 설명하시오
>- 추상 클래스와 인터페이스의 차이에 대해 설명하시오
>- java reflection에 대해 설명하시오
>- 직렬화와 역직렬화에 대해 설명하시오
>- StringBuilder와 StringBuffer의 차이를 설명하시오
>- Java 8에 추가된 기능을 설명하시오
>- Lambda란 무엇이고 어떠한 장점이 있는지 설명하시오
>- Stream API 특징이나 장점에 대해 설명하시오
>- Garbage Collector(GC)에 대해 설명하시오
>- GC에 의해 변수가 초기화되는 시점을 설명하시오
>- JAVA의 바이트코드에 대해 설명하시오
>- 예외처리 방법을 설명하시오
>- 런타임(Runtime)과 컴파일타임(Compiletime)의 차이점에 대해 설명하시오
>- JAVA 동작 원리에 대해 설명하시오
>- 자바에서 쓰레드를 구현하기 위한 2가지 방법을 간단하게 설명하시오
>- Collection 정의와 종류를 설명하시오
>- ArrayList와 LinkedList의 차이를 설명하시오
>- CheckedException과 UnCheckedException의 차이를 설명하시오
>- Synchronized(동기화)를 하기 위한 방법을 설명하시오
>- try-with-resource에 대해 설명하시오
>- Functional Interface에 대해 설명하시오
>- Default Method에 대해 설명하시오
>- Method Reference에 대해 설명하시오
>- Optional 클래스에 대해 설명하시오
>- 업캐스팅과 다운캐스팅의 차이를 설명하시오
>- this 키워드는 언제 사용되는지 설명하시오

<br>

[목차로 이동](#목차)

>### Java답변
>[[문제]](#java문제)
>- 객체지향 프로그래밍과 절차지향 프로그래밍의 차이에 대해 설명하시오
>>- 절차지향은 데이터 중심의 함수를 구현하여 프로그램을 순차적으로 처리하는 방식이며 속도가 빠른 장점이 있으나 코드의 변경이 이루어질때 프로젝트의 규모가 클수록 유지보수에 어려움이 있습니다
>>- 객체지향은 기능 중심으로 데이터와 기능을 묶어서 개발하는 방식이며 코드의 재활용성이 높다는 장점이 있으나 설계하는 데 시간이 오래걸립니다
>- 객체지향 프로그래밍의 특징에 대해 설명하시오
>>- 캡슐화, 상속, 추상화, 다형성 4개의 특징이 있음
>>- 캡슐화는 연관 있는 변수와 함수를 클래스로 묶는 작업을 의미함
>>- 상속은 자식 클래스가 부모 클래스의 특성과 기능을 물려받아 재사용성을 높이는 역할을 함
>>- 추상화란 인터페이스로 공통적인 특성들을 묶어 표현하는 것을 의미함
>>- 다형성은 같은 메서드명인데 여러 상황에 맞추어 다른 기능을 수행하게 하는것으로 오버로딩과 오버라이딩이 대표적인 예시임
>- 객체지향 설계 5원칙에 대해 설명하시오
>>- SOLID, SRP(단일 책임 원칙), OCP(개방-폐쇄 원칙), LSP(리스코프 치환 원칙), ISP(인터페이스 분리 원칙), DIP(의존 역전 원칙), 시간이 지나도 유지 보수와 확장이 쉬운 소프트웨어를 만드는데 이 원칙을 적용함
>>- Single Responsibility Principle
>>>- 객체는 단 하나의 책임만 가져야한다
>>>- 시스템에 변화가 생기더라도 영향을 최소화할 수 있음
>>- Open-Close Principle
>>>- 기존의 코드를 변경하지 않으면서, 기능을 추가할 수 있도록 설계되어야 한다
>>>- 확장에 대해서는 개방적이고 수정에 대해서는 폐쇄적으로 설계되어야 한다는 의미
>>- Liskov's Substitution Principle
>>>- 자식 클래스는 최소한 자신의 부모 클래스에서 가능한 행위는 수행할 수 있어야 한다는 설계 원칙
>>- Interface Segregation Principle
>>>- 자신이 사용하지 않는 인터페이스는 구현하지 말아야 한다는 설계 원칙
>>- Dependency Inversion Principle
>>>- 객체들이 서로 정보를 주고 받을 때 의존 관계가 형성되는데, 이 때 객체들은 나름대로의 원칙을 갖고 정보를 주고 받아야 한다는 설계 원칙
>- 오버로딩과 오버라이딩에 대해 설명하시오
>>- 오버로딩은 메서드의 이름은 같고, 매개변수의 개수나 타입이 다른 함수를 정의하는 것
>>- 오버라이딩은 상위 클래스의 메서드를 하위 클래스에서 재정의 하는것
>- 클래스와 객체의 차이를 설명하시오
>>- 클래스는 설계도, 객체는 설계도로 구현한 모든 대상을 의미함
>- 객체와 인스턴스의 차이를 설명하시오
>>- 클래스의 타입으로 선언되었을 때 객체라고 부르고, 그 객체가 메모리에 할당되어 실제 사용될 때 인스턴스라고 함
>- 자바의 특징에 대해 설명하시오
>>- 자바는 객체지향적 프로그래밍 언어로 플랫폼 독립성, 멀티쓰레드, 자동 메모리 관리 등의 특징을 가지고 있음
>- Java SE와 EE의 차이를 설명하시오
>>- Java SE란 Java Platform Standard Edition의 약자로 데스크톱, 서버, 임베디드를 위한 표준 자바 플랫폼을 뜻함
>>- Java EE란 Java Platform Enterprise Edition의 약자로 자바를 이용한 서버측 개발을 위한 플랫폼으로 SE에 서버측을 위한 기능을 추가하여 SE의 모든 기능을 이용할 수 있음
>- 참조형 변수와 기본형 변수의 차이를 설명하시오
>>- 기본형 변수엔 실제 사용되는 데이터가 저장되고 byte, short, int, long, float, double, boolean, char 등이 있으며 스택에 저장됨
>>- 참조형 변수엔 실제 데이터의 위치를 담은 주소값이 저장됨
>- 변수의 3가지 타입에 대해 설명하시오
>>- 로컬 변수는 메서드 내에서 선언된 위치부터 소속된 중괄호가 끝나는 지점까지 사용가능함
>>- 인스턴스 변수는 클래스를 통해 생성된 인스턴스 내에서 접근이 가능함
>>- 클래스 변수는 클래스의 모든 인스턴스에서 공유하는 변수로서 클래스가 메모리에 올라갈 때 static 영역에 생성됨
>- Wrapper Class에 대해 설명하시오
>>- 8개의 기본 타입에 해당하는 데이터를 객체로 포장해주는 클래스
>>- Wrapper 클래스를 이용할 때 주의할 점으로 참조형끼리는 연산이 불가능하기 때문에 기본 자료형으로 변환하여 연산해야함
>- public 접근 제어자와 private 접근 제어자의 차이를 설명하시오
>>- public 은 같은 패키지 안의 클래스뿐 아니라, 다른 패키지 안의 클래스에서도 사용가능
>>- private 은 오로지 그 클래스에서만 사용할 수 있음
>- Boxing, Unboxing에 대해 설명하시오
>>- 기본형을 Wrapper 클래스로 바꿔주는 것이 박싱, 반대로 Wrapper 클래스 타입의 값을 기본형으로 바꿔주는 것을 언박싱
>>- 자바 1.5 부터 오토박싱, 오토언박싱을 지원하지만, 메모리 누수의 원인이 될 수 있음
>- non-static 멤버와 static 멤버의 차이를 설명하시오
>>- static 멤버는 클래스당 하나만 생성, non-static 멤버는 객체마다 별도로 존재
>>- static 멤버는 동일한 클래스의 모든 객체들에 의해 공유되는 특성을 가짐
>- main 메서드가 public static 인 이유를 설명하시오
>>- 어떤 패키지에 있던지 main 메서드는 JVM에 의해 가장 먼저 실행되야 하므로 public을 사용
>>- 실행 전 main 메서드는 메모리에 적재되어 있어야 하므로 static으로 선언되야함
>- final 키워드의 용도에 대해 설명하시오
>>- 변수, 메서드, 클래스에 사용할 수 있으며 변수에 사용 시 값이 변경 불가능하고, 메서드에 사용 시 오버라이딩을 못하게 만들며, 클래스에 사용 시 상속을 할 수 없게 만듬
>- Generic에 대해 설명하시오
>>- 객체 타입을 컴파일 시에 체크해줌
>>- 컴파일 시에 타입을 체크하므로 타입 안정성을 높이고 형변환의 번거로움을 줄일 수 있음
>- ==과 equals()의 차이를 설명하시오
>>- ==는 두 객체가 같은 메모리 공간을 가리키는지 확인
>>- equals()는 두 객체의 값이 같은지를 확인하는 메서드
>- Call by Reference와 Call by Value에 대해 설명하시오
>>- call by reference는 주소값을 호출, call by value는 실제 값을 호출
>>- 메서드의 매개변수 값을 복사하여 처리하는지, 직접 참조하는지의 차이
>>- call by value로 넘어온 객체의 값이 변경되어도 원래 값에는 영향이 없고, call by reference로 넘어온 객체의 값이 변경되면 원래 값에도 영향을 줌
>- 추상 클래스와 인터페이스의 차이에 대해 설명하시오
>>- 추상클래스는 공통점을 찾아 추상화하는것, 인터페이스는 구현 객체가 같은 동작을 하도록 보장하는 것
>>- 추상 클래스는 is a (~이다), 인터페이스는 has a(~을 할 수 있는), 또한 인터페이스는 다중상속이 가능함
>- java reflection에 대해 설명하시오
>>- 동적으로 클래스를 사용할 때 필요한 API
>>>- 작성 시점에는 어떤 클래스를 사용해야 할지 모르는 경우, 런타임 시점에서 클래스를 가져와서 실행해야 하는 경우에 사용됨. 대표적으로 인텔리제이의 자동완성이나 스프링의 어노테이션 같은 기능들이 리플렉션을 이용하여 프로그램 실행 중 동적으로 클래스 정보를 가져와서 사용하는 예
>- 직렬화와 역직렬화에 대해 설명하시오
>>- 직렬화는 객체를 파일에 저장하거나 네트워크를 통해 전달할 수 있도록 변환하는 과정
>>- 역직렬화는 직렬화된 데이터를 불러와 다시 객체로 변환하는 과정
>- StringBuilder와 StringBuffer의 차이를 설명하시오
>>- StringBuilder는 동기화 처리를 하지 않아 StringBuffer보다 속도가 더 빠름
>>- StringBuffer는 속도는 느리지만 멀티 스레드 환경에서 안전하게 사용할 수 있음
>- Java 8에 추가된 기능을 설명하시오
>>- java.time 패키지와 스트림 API, 람다 표현식이 추가
>- Lambda란 무엇이고 어떠한 장점이 있는지 설명하시오
>>- "식별자없이 실행가능한 함수"인데 함수를 따로 만들지 않고 코드 한줄에 함수를 써서 그것을 호출하는 방식으로 코드를 줄여 간단하게 작성 가능하고 가독성이 증가
>- Stream API 특징이나 장점에 대해 설명하시오
>>- 원본 데이터를 변경하지 않고 가공된 데이터를 추출함
>>>```java
>>>List<Integer> list=new ArrayList<>();
>>>long count=list.stream().filter(x->x>3).count();
>>>```
>- Garbage Collector(GC)에 대해 설명하시오
>>- 메모리를 따로 해제할 필요없이 힙 영역에서 더이상 사용되지 않을 객체들(쓰레기 객체)을 찾아 메모리를 해제하여 자동으로 정리해주는 것
>- GC에 의해 변수가 초기화되는 시점을 설명하시오
>>- 지역변수는 scope가 끝나거나 변수에 다른 객체를 삽입하면 초기화됨
>>- 전역변수의 경우 프로그램이 종료되면 초기화됨
>>- GC 동작 원리
>>>- 처음 생성된 객체는 Eden에 위치
>>>- Minor GC 발생 후에 살아있다면 Suvivor 영역으로 이동
>>>- Survivor에서 살아남은 객체는 Old Generation 영역으로 이동
>- JAVA의 바이트코드에 대해 설명하시오
>>- 자바 가상 머신이 이해할 수 있는 언어로 변환된 자바 소스 코드 (ex, class파일)
>- 예외처리 방법을 설명하시오
>>- 복구형 / try, catch 블록
>>>- 예외 발생 가능성이 있는 코드를 try로 감싸고, 발생 시에 처리는 catch에서 받음
>>>- try with resource : try에 자원 객체를 전달하면, try 코드 블록이 끝날때 자동으로 자원을 종료
>>- 회피형 / throw 키워드 선언
>>>- 메서드 끝단에 throws Exception 을 선언하여 처리, 예외 발생 시, 메서드를 호출한 코드로 예외를 되돌려 보내어 처리하게하는 방식
>>- 전환형 / catch에서 다른 예외를 던지는 것
>>>- 호출 측에서 에러의 타입을 명확하게 인지할 수 있도록 예외를 던짐
>- 런타임(Runtime)과 컴파일타임(Compiletime)의 차이점에 대해 설명하시오
>>- 소스코드를 작성하고 컴파일이라는 과정을 통해 기계어코드로 변환되어 실행 가능한 프로그램이 되는데 이러한 편집 과정을 컴파일타임이라고 함
>>- 컴파일 과정을 마친 프로그램은 사용자에 의해 실행되어 지며, 이러한 응용프로그램이 동작되어지는 때를 런타임이라고 함
>- JAVA 동작 원리에 대해 설명하시오
>>1. 소스코드가 컴파일러에 의해 바이트코드(.class)로 컴파일
>>2. 바이트코드를 클래스 로더에 전달
>>3. 클래스로더에 의해 import한 클래스들이 읽힘
>>4. 런타임 데이터 영역에 의해 JVM 메모리에 올라감
>>5. 실행엔진은 JVM 메모리에 올라온 바이트 코드를 하나씩 가져와 실행함
>- 자바에서 쓰레드를 구현하기 위한 2가지 방법을 간단하게 설명하시오
>>- Runnable 인터페이스를 확장해 run() 메서드 구현
>>- Thread 클래스를 상속받고 run() 메서드를 오바라이딩해 구현
>- Collection 정의와 종류를 설명하시오
>>- 컬렉션 프레임워크란 다수의 데이터를 쉽고 효과적으로 처리할 수 있는 표준화된 방법을 제공하는 클래스의 집합
>- ArrayList와 LinkedList의 차이를 설명하시오
>>- ArrayList
>>>- 내부적으로 데이터를 배열로 관리하고, 데이터 추가/삭제 시 임시 배열을 생성해 데이터를 복사함
>>>- 데이터별 인덱스가 있어 검색에는 유리하지만 임시 배열을 사용하기 때문에 데이터 추가/삭제는 불리함
>>- LinkedList
>>>- 내부적으로 노드 단위로 데이터를 관리하여, 자신의 앞 뒤 노드만 인지하는 상태
>>>- 인덱스가 따로 없기 때문에 검색 시 전 노드를 순회해야하여 불리하지만 데이터 추가/삭제 시 불필요한 데이터 복사가 없어 유리함
>- CheckedException과 UnCheckedException의 차이를 설명하시오
>>구분|CheckedException|UnCheckedException
>>:--|:--|:--
>>확인시점|컴파일 시점|런타임 시점
>>처리여부|반드시 예외 처리|명시적으로 예외처리 하지않아도 됨
>>트랜잭션처리|예외 발생 시 롤백하지 않음|예외 발생 시 롤백
>- Synchronized(동기화)를 하기 위한 방법을 설명하시오
>>- synchronized 함수(메서드)를 만들어 사용
>>- synchronized 블록(block) 사용
>- try-with-resource에 대해 설명하시오
>>- try에서 선언된 객체가 AutoCloseable을 구현하였다면 Java는 try구분이 종료될 때 객체의 close() 메서드를 자동으로 호출하여 해제함
>- Functional Interface에 대해 설명하시오
>>- 정확히 하나의 추상 메서드가 정의된 인터페이스
>>- Predicate, Comparator, Runnable 인터페이스 등이 존재함
>- Method Reference에 대해 설명하시오
>>- 람다 표현식을 직접 작성하는 대신에 기존의 메서드 정의를 이용하는 방법으로, 기존의 메서드 정의와 동일한 람다 표현식을 매번 작성하는 불편함에서 나온 기법으로 가독성을 높일 수 있음
>>```java
>>interface Executable {
>>  void doSomething(String text);
>>}
>>
>>public static class Printer {
>>  static void printSomething(String text) {
>>    System.out.println(text);
>>  }
>>}
>>
>>public static void main(String args[]) {
>>  Executable exe = text -> Printer.printsomething(text); // 람다 표현식
>>  Executable exe2 = Printer::printSomething; // 메서드 레퍼런스
>>  exe.doSomething("do something");
>>  exe2.doSomething("do something");
>>}
>>```
>- Default Method에 대해 설명하시오
>>- 메서드 구현을 포함하는 인터페이스를 정의하기 위해 사용됨
>>- 이 인터페이스를 구현하는 클래스는 인터페이스에 디폴트 메서드도 상속받게 되므로 서브클래스는 최소한의 메서드만 구현해도 됨
>>```java
>>interface MyInterface {
>>  default void printHello() {
>>    System.out.println("Hello world");
>>  }
>>}
>>```
>- Optional 클래스에 대해 설명하시오
>>- NullPointerException을 관리하기 위해 기존 객체를 감싼 Wrapper Class
>>- Optional 인스턴스는 모든 타입의 참조변수를 저장할 수 있음
>>```java
>>Optional<String> opt = Optional.ofNullable("Optional 객체");
>>if(opt.isPresent()) {
>>  System.out.println(opt.get());
>>}
>>```
>- 업캐스팅과 다운캐스팅의 차이를 설명하시오
>>- 서브클래스의 객체가 슈퍼클래스 타입으로 형변환 되는 과정을 업캐스팅
>>- 업캐스팅된 변수의 타입을 서브클래스로 변경하는 것을 다운캐스팅
>- this 키워드는 언제 사용되는지 설명하시오
>>- 클래스의 속성과 생성자/메서드의 매개변수의 이름이 같은 경우
>>- 클래스에 오버로딩된 다른 생성자 호출

<br>

[목차로 이동](#목차)

---

## Operating System

>### Operating System문제
>[[답변]](#operating-system답변)
>- dd

<br>

[목차로 이동](#목차)

>### Operating System답변
>[[문제]](#operating-system문제)
>- dd

<br>

[목차로 이동](#목차)

---

## Network

>### Network문제
>[[답변]](#network답변)
>- dd

<br>

[목차로 이동](#목차)

>### Network답변
>[[문제]](#network문제)
>- dd

<br>

[목차로 이동](#목차)

---

## Database

>### Database문제
>[[답변]](#database답변)
>- dd

<br>

[목차로 이동](#목차)

>### Database답변
>[[문제]](#database문제)
>- dd

<br>

[목차로 이동](#목차)

---