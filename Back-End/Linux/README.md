# **Linux** ⌨

### 참고자료

- 리눅스를 다루는 기술

## 목차
>- [명령행 인터페이스](#명령행-인터페이스)
>>- [명령행 인터페이스로 시스템 관리하기](#명령행-인터페이스로-시스템-관리하기)
>>- [시작하고 종료하기](#시작하고-종료하기)
>>- [사용자 관리하기](#사용자-관리하기)
>>- [파일 관리하기](#파일-관리하기)
>>- [프로세스 관리하기](#프로세스-관리하기)
>>- [패키지 관리하기](#패키지-관리하기)
>>- [서비스 관리하기](#서비스-관리하기)
>>- [vi 편집기 익히기](#vi-편집기-익히기)
>- [리눅스 가상 시스템](#리눅스-가상-시스템)
>>- [리눅스 가상 시스템이란](#리눅스-가상-시스템이란)


<br>

---

## 명령행 인터페이스

>### 명령행 인터페이스로 시스템 관리하기
>- 명령행 인터페이스 (Command Line Interface, CLI)
>>- 사용자가 키보드로 문자열 명령을 입력하고 컴퓨터가 처리한 결과를 화면에서 확인하는 상호작용
>- 명령행 인터페이스를 사용하는 이유
>>- 시스템 자원을 덜 소모하고 효율적으로 시스템을 관리할 수 있음
>>- 서비스를 빠르고 안정적으로 제공하는 일이 더 중요한 서버 컴퓨터에서는 GUI보다 CLI가 선호됨
>>- 시스템에 문제가 발생해서 GUI를 사용할 수 없는 응급 상황에서도 CLI는 사용 가능함
>- 셸 (shell)
>>- 사용자가 입력한 명령을 운영체제가 이해할 수 있게 변환하기 때문에 명령어 해석기라고도 함
>>- 커널 내부에서 이루어지는 일에 신경을 쓰지 않아도 셸로 시스템을 제어할 수 있음
>>- 다른 프로그램들을 실행하는 프로그램임
>>- 우분투를 비롯한 다른 여러 리눅스 운영체제의 기본 셸은 배시 (Bourne Again SHell, BASH)
>- 셸의 명령 입출력 과정
>>- user@ubuntu:~$
>>>- 셸이 사용자에게서 명령을 받을 준비가 되었음을 의미하는 프롬프트
>>- user@ubuntu:~$ echo HelloBash
>>>- echo : 배시가 제공하는 문자열 출력 명령
>>- 화면에 문자열을 표시하는 아주 단순한 명령이지만 echo 명령이 어떤 일을 하는지, 명령에 필요한 인자와 사용 가능한 옵션에는 무엇이 있는지 알고 있어야 함
>>- CLI에 익숙하다는 것은 셸을 잘 다룬다는 의미
>>- 능숙한 리눅스 시스템 관리자는 셸에서 사용 가능한 명령들을 알고 있어야 하며, 원하는 결과를 얻는 데 필요한 명령들을 조합하여 처리할 수 있어야 함
>- 셸 명령 옵션
>>- 어떤 명령은 세부 기능을 선택할 수 있도록 옵션을 제공함
>>- 옵션은 기호 --나 -로 시작하며ㅡ 영문 대,소문자로 입력함
>>- --로 시작하는 옵션은 이름으로 의미를 알기 쉽지만 여러 문자를 입력해야 함
>>- -로 시작하는 축약형 옵션은 편리하지만 어느 정도 암기가 필요
>>- 예시
>>>- user@ubuntu:~$ useradd --help 와 user@ubuntu:~$ useradd -h 는 같음
>>- 여러 옵션을 조합하여 편리하게 사용할 수 있음
>>>- $ ls : 파일 목록을 화면에 보여줌
>>>>- -a : 숨김 파일까지 모두 표시
>>>>- -l : 파일 정보를 함께 출력
>>>- user@ubuntu:~$ ls -al 처럼 옵션 조합을 할 수 있음 (대부분 순서와 상관 없이 명령을 처리함)

<br>

[목차로 이동](#목차)

>### 시작하고 종료하기
> 명령|설명
> :--|:--
> logout|셸 사용을 종료하고 로그인 대기 상태로 돌아감
> printenv|설정된 모든 환경변수를 출력
> export|환경변수를 등록
> unset|등록한 환경변수를 삭제
> shutdown|시스템을 종료
> reboot|시스템을 다시 시작
>- 셸 시작하기
>>- user@ubuntu:~$
>>>- user : 로그인한 사용자 계정
>>>- ubuntu : 호스트 이름 (네트워크에서 컴퓨터를 식별할 수 있는 이름)
>>>- ~ : 틸트라고 불리며 현재 작업 디렉토리 위치를 나타냄
>>>- $ : 로그인한 사용자 권한을 나타냄
>>>>- $ 은 일반 사용자 권한
>>>>- \# 는 루트 권한을 의미하지만 우분투는 기본적으로 루트 로그인을 권장하지 않으므로 시스템 복구할 때 외에는 볼 일이 없음
>- 셸 환경변수
>>- $ printenv
>>>- 현재 설정된 모든 환경변수를 출력
>>- 환경변수 : 사용자가로그인한 시스템이 동작하는 방식에 영향을 미치는 변수
>>- 중요한 환경변수 설명
>>>- SHELL : 현재 로그인한 셸
>>>>- 배시 셸의 경우 /bin/bash
>>>- PWD : 현재 작업 디렉토리 경로
>>>- LOGNAME : 로그인한 사용자 이름
>>>- HOME : 사용자 홈 디렉토리 경로
>>>- LANG : 로케일 설정
>>>- PATH : 실행할 명령을 찾는 경로
>>- 변수 정의
>>>- [변수명]=[값] 형식으로 입력하여 셸에서 사용할 변수를 정의
>>>>- $ VAR=1
>>>>- $ echo \$VAR
>>>>>- 변수를 사용할 때 변수 이름 앞에 스트링($)을 붙여야 함
>>>>-  사용자가 실행하는 명령은 셸의 자식 프로세스로 동작하기때문에 위에서 등록한 VAR 변수는 자식 프로세스에서 사용할 수 없고 printenv에 출력되지 않음
>>- 환경변수 설정 및 삭제
>>>- $ export VAR=1 
>>>>- 변수를 환경변수로 내보냄
>>>>- 이후 printenv 에 출력됨
>>>- $ unset VAR
>>>>- 환경변수를 삭제함
>>>- 환경변수 저장
>>>>- export 명령으로 내보낸 환경변수는 로그인 상태에서만 유지되며 터미널을 닫거나 로그아웃하면 초기화됨
>>>>- 환경변수를 계속 유지하려면 환경 설정 파일에 등록해야 함
>>>>- 현재 로그인한 사용자에 해당하는 환경변수는 홈 디렉토리의 배시 환경 설정 파일 .bashrc에 export 명령으로 등록
>>>>- 시스템 전체에 적용하려면 /etc/environment에 등록
>- 시스템 종료
>>- $ sudo shutdown [시간] [옵션]
>>>- -h : 명령을 실행한 이후 전원을 차단하는 옵션
>>>- -now : 지금 즉시 명령 실행
>>>- $ sudo shutdown -h now : 즉시 시스템 종료
>>>- $ sudo shutdown -h 15 : 15분 후 시스템 종료
>>>- $ sudo shutdown -h 03:30 : 3시 30분에 시스템 종료
>>>- $ sudo shutdown -c : 예약 종료 취소
>>>- $ sudo shutdown -r now : 시스템 재부팅
>>>>- $ sudo reboot 시스템을 재부팅할 수 있는 또 다른 명령

<br>

[목차로 이동](#목차)

>### 사용자 관리하기
> 명령|설명
> :--|:--
> $ whoami|로그인한 사용자 계정 표시
> $ who|사용자의 접속 정보 표시
> $ w|현재 접속한 사용자 정보와 시스템 정보를 함께 표시
> $ sudo|시스템 관리 권한 획득
> $ useradd, $ userdel|사용자 계정 추가, 삭제
> $ passwd|로그인 비밀번호 변경
> $ usermod|사용자 계정 정보 수정
> $ groups|사용자가 속해 있는 그룹 조회
> $ groupadd, $ groupdel|그릅 생성, 삭제
> $ gpasswd|그룹 정보 수정
>- 로그인한 사용자 정보 조회
>>- $ whoami
>>>- 현재 로그인한 사용자 계정을 화면에 표시
>>- $ who
>>>- 로그인한 사용자 계정과 접속한 터미널 정보, 로그인한 시각과 접속한 IP 주소 정보 출력
>>>- 접속자가 여럿이면 각각의 접속 정보가 표시
>>>- :0 은 그래픽 환경에서 생성된 첫 번째 터미널임을 의미
>>>>- 접속 환경에 따라 터미널 정보가 달라짐
>>>>- 우분투 서버에 직접 접속하는 콘솔 환경에서 who 명령 실행 시 터미널 정보는 tty1로 표시
>>>>- ssh를 이용하여 원격 접속 시 터미널 정보는 pts/0으로 표시
>>>>>- tty : 기본 터미널 장치 (teletypewriter)
>>>>>- pts : 의사 터미널 장치 (pseudo terminal)
>>- $ w
>>>- 현재 접속해 있는 사용자 정보와 함께 시스템 정보를 화면에 출력
>- 루트 권한 획득하기
>>- 리눅스는 여러 사용자가 동시에 사용 가능한 다중 사용자 운영체제임
>>>- 사용자는 권한에 따라 시스템 자원에 대한 접근, 사용 여부가 결정됨
>>- 시스템을 제어하는 명령을 실행하려면 시스템 관리 권한(루트) 권한이 필요
>>>- 시스템 관리(루트) 권한을 가지고 있는 사용자 계정을 루트 사용자 또는 슈퍼유저라고 함
>>>- 루트는 시스템을 제어할 수 있는 최상위 계정의 권한을 의미
>>- 리눅스는 루트 사용자의 로그인을 제한하기 때문에 시스템 관리자도 일반 사용자 계정으로 로그인해야 하며, 루트 권한이 필요할 때 루트 권한을 획득하는 과정을 거침
>>- 루트 권한이 필요한 명령을 처리할 때 sudo 명령을 사용
>>>- sudo는 다른 사용자 권한을 획득해서 명령을 실행하는 명령
>>- $ apt update : 권한이 없어 오류 메시지 표시됨
>>- $ sudo apt update : 패스워드 입력 시 패키지 목록을 업데이트
>>>- 패스워드를 잘못 입력하거나 해당 사용자가 루트 권한이 없다면 오류발생
>>- sudo로 획득한 루트 권한은 일정 기간 유지되어 매번 패스워드를 입력할 필요 없음
>- 사용자 계정 추가하기
>>- $ sudo useradd [옵션] [사용자 계정]
>>>- 시스템에 새로운 사용자 계정을 추가
>>>- -m (--create-home) 옵션을 붙이면 사용자 계정을 추가함과 동시에 홈 디렉토리를 함께 생성
>>>>- $ sudo useradd -m user123
>>>>- $ ls /home
>>- $ sudo passwd [사용자 계정]
>>>- 새로 추가한 사용자 계정의 패스워드를 변경
>>>- 현재 로그인한 사용자 계정의 패스워드를 변경할 때는 $ passwd만 입력
>>- $ cat /etc/passwd
>>>- 사용자 계정 목록을 확인
>>>- $ cat : 파일 내용 출력
>>>- [사용자 계정]:[패스워드]:[UID]:[GID]:[추가정보]:[홈 디렉토리]:[로그인 셸] 형식으로 출력
>>>>- 사용자 계정 : 시스템 운영을 위해 자동으로 생성된 사용자 계정이 대부분이며, 설치 과정에서 등록한 사용자, useradd로 추가한 사용자 계정을 확인할 수 있음
>>>>- 패스워드 : 아주 오래된 리눅스 시스템은 패스워드를 평문으로 저장, 현재 패스워드는 암호화해서 저장되므로 x로 표시
>>>>- UID : 사용자 계정을 식별하는 고유 번호 (User ID)
>>>>- GID : 사용자가 속해 있는 그룹 식별 번호 (Group ID)
>>>>- 추가정보 : 설치 과정에서 실제 이름을 입력했다면 추가 정보로 저장되며 adduser 명령에서 입력하는 정보들이 여기에 저장됨
>>>>>- $ adduser [사용자 계정]
>>>>>>- useradd와 passwd를 한 번에 사용하는 효과
>>>>>>- 사용자 추가 정보를 입력할 수 있음
>>>>- 홈 디렉토리 : 로그인 후 사용하는 기본 작업 디렉토리 경로
>>>>- 로그인 셸 : 로그인 후 사용할 기본 셸을 지정
>>- $ sudo userdel [옵션] [사용자 계정]
>>>- -r (--remove) 옵션 사용시 사용자 홈 디렉토리까지 함께 제거
>>>- -r 옵션을 사용하지 않은 경우 처리
>>>>- $ sudo userdel user123
>>>>- $ sudo rm -rf /home/user123
>- 사용자 계정 전환하기
>>- $ sudo cat /etc/sudoers
>>>- sudo를 실행할 수 있는 권한은 sudo 설정 파일인 /etc/sudoers 에서 지정함
>>>- 명령 실행시 사용자 계정 root와 그룹 admin, 그룹 sudo에 속하는 사용자는 모든 명령에 대해 sudo로 루트 권한을 얻을 수 있음을 확인할 수 있음
>>- $ su [옵션][사용자 계정]
>>>- 사용자 계정을 전환
>>>- $ whoami : su 명령으로 전환한 사용자 계정이 표시
>>>- $ who : 로그인한 사용자 계정 정보를 표시되므로 su 명령을 자주 사용할 때 처음 로그인한 사용자 계정을 확인하기 위해 쓰임
>>- $ groups
>>>- 사용자가 속해 있는 그룹을 조회
>>>- 계정 생성시 자동으로 같은 이름의 사용자 그룹이 생성됨
>>>- sudoers 파일에 등록된 사용자가 아닌 경우 sudo를 사용할 수 없음
>>>- exit를 입력하면 su 명령 전 원래 사용자 계정으로 복귀함
>>- $ sudo usermod [옵션] [사용자 계정]
>>>- -a (--append) : 변경 대신 정보를 추가하는 옵션
>>>>- 해당 옵션이 없으면 사용자 계정의 그룹은 추가가 아닌 변경이 되어 기존 정보가 모두 삭제됨
>>>- -G (--groups) : 사용자 계정의 그룹을 대상으로 함
>>>- $ sudo usermod -a -G sudo user123
>>>>- user123 계정을 sudo 그룹에 포함시킴
>>>- $ sudo useradd -m -G sudo user123
>>>>- 새로운 사용자 계정을 추가하는 과정에서 그룹을 지정하여 번거로움을 피할 수 있음
>>>- $ sudo chsh -s /bin/bash user123
>>>>- 사용자 계정의 사용 셸 변경
>>>- $ sudo gpasswd -d [사용자 계정] [삭제할그룹]
>>>>- 단순히 그룹에서 사용자를 삭제하려면 그룹 관리 명령인 gpasswd가 편리함
>- 그룹 관리하기
>>- $ sudo groupadd [옵션] [그룹]
>>>- 새로운 그룹을 생성
>>- $ sudo gpasswd -a [사용자 계정] [그룹명]
>>>- -a (--add) : 그룹에 사용자를 추가
>>- $ sudo gpasswd -M [사용자 계정],[사용자 계정],..., [그룹명]
>>>- 그룹에 여러 사용자를 한번에 추가
>>- $ groups [사용자 계정]
>>>- 해당 사용자가 속해 있는 그룹을 출력
>>- $ sudo cat /etc/group
>>>- 모든 그룹 정보 출력
>>- $ sudo gpasswd -d [사용자 계정] [그룹명]
>>>- 그룹에서 사용자를 삭제, -d (--delete)
>>- $ sudo groupdel [그룹명]
>>>- 그룹 삭제

<br>

[목차로 이동](#목차)

>### 파일 관리하기
> 명령|설명
> :--|:--
> ls|파일 목록 조회
> chown|파일 소유권 변경
> chmod|파일 접근 권한 변경
> pwd|작업하고 있는 디렉토리 위치 출력
> cd|작업 디렉토리 변경
> mkdir, rmdir|디렉토리 생성, 삭제
> touch|빈 파일 생성
> cp, mv, rm|파일 복사, 이동, 삭제
> cat|파일 내용을 화면에 표시
> more, less|파일 내용을 스크롤
> head, tail|파일 내용 중 일부를 표시
> find, which, whereis, grep|파일 검색
>- 리눅스에서의 파일
>>- 리눅스에선 텍스트, 이미지, 영상 뿐 아니라 파일을 묶는 디렉터리, 네트워크 소켓 등 자료 흐름과 시스템 장치까지 모든 것이 파일임
>>- 다중 사용자 운영체제인 리눅스에서는 모든 파일마다 파일을 소유하는 사용자 계정 정보와 해당 파일에 대한 접근 권한이 부여됨
>>- 사용자는 파일을 사용하기 전에 그 파일을 제어할 수 있는 소유권과 접근 권한을 갖고 있는지 확인해야 함
>- $ ls [옵션] [파일]
>>- 파일 목록 화면에 표시
>>- -l : 긴 리스트 포맷을 사용하여 출력
>>- -h (--human-readable) : 파일 용량을 MB, GB 단위로 바꾸어 출력
>>- -a (--all) : 숨김 파일까지 출력
>- 파일 정보에 대해
>>- ls -l 명령으로 출력되는 파일 목록 형식
>>>- 접근 권한 | 링크 | 소유자 | 소유 그룹 | 크기 | 최종 변경한 날짜와 시간 | 파일이름
>>- 파일 접근 권한 해석
>>>- drwxrwxr-x
>>>- 첫 문자가 d 이면 디렉터리, - 이면 일반 파일, l 이면 링크
>>>- 다음 세 문자는 차례로 소유자, 소유자가 포함된 그룹, 다른 모든 사용자에 대한 읽기, 쓰기, 실행 권한의 유무
>>>- rwx 대신 -가 표시되어 있다면 각 권한이 없음을 의미함
>- 파일 소유권과 접근 권한 변경하기
>>- $ touch [옵션] [파일명]
>>>- 파일의 날짜와 시간 정보를 건드려 바꾸는 명령
>>>- $ touch [파일명]
>>>>- 아무런 옵션이 없으면 아무 내용 없는 빈 파일 생성
>>- $ sudo chown [옵션] [사용자 계정 및 그룹] [파일]
>>>- 파일의 소유권을 변경
>>>- $ sudo chown user123 /tmp/tempfile : 소유자만 변경
>>>- $ sudo chown user123:user123 /tmp/tempfile : 소유자와 그룹 함께 변경
>>- 폴더의 소유권도 같은 방법으로 변경가능하며, 폴더 내 파일들의 소유권은 그대로 유지됨
>>- $sudo chown -R [사용자 계정 및 그룹] [파일]
>>>- -R (--recursive) 옵션 사용시 디렉토리와 디렉토리에 있는 파일의 소유권을 함께 변경
>>>- 디렉토리내에 디렉토리가 있다면 그 안의 파일들도 모두 변경됨
>>- $ chmod [레퍼런스] [연산자] [접근 권한] [파일]
>>>- 파일의 접근 권한을 변경
>>>- 레퍼런스 : 변경할 대상 소유자, 그룹, 다른 모든 사용자를 뜻하며 차례로 u(user), g(group), o(other)로 표시하며 a(all)는 소유자, 그룹, 다른 모든 사용자를 통칭함
>>>- 권한을 부여하는 연산자는 +, 권한을 해제하는 연산자는 -
>>>- 변경할 접근 권한은 읽기, 쓰기, 실행으로 각각 r(read),w(write),x(excute)로 표시함
>>>- $ chmod ugo+rwx /tmp/tempfile
>>>>- 시스템에 존재하는 모든 사용자가 이 파일을 읽고 쓰고 실행할 수 있는 상태로 변경
>>>- $ chmod o-rwx /tmp/tempfile
>>>- 다른 사용자들은 파일을 읽거나 수정, 실행할 수 없도록 변경
>>- 8진수를 활용한 접근 권한 변경
>>>- 백의자리 : 파일소유자
>>>- 십의자리 : 소유자가 속한 그룹
>>>- 일의자리 : 다른 사용자
>>>- 4 : 읽기 권한
>>>- 2 : 쓰기 권한
>>>- 1 : 실행 권한
>>>- $ chmod 444 /tmp/tempfile
>>>>- 모든 사용자에게 읽기 권한 부여
>>>- $ chmod 777 /tmp/tempfile
>>>>- 모든 사용자에게 모든 권한 부여
>- 리눅스 시스템 디렉토리
>>- 시스템 디렉토리
>>>- 우분투 설치시 파일 시스템에 시스템 디렉토리가 생성되며 파일 시스템 계층 구조 표준에 따라 트리 구조로 구성됨
>>>- 시스템 디렉토리는 중요한 의미를 갖기 때문에 함부로 삭제하거나 변경하면 안됨
>>>- 시스템 디렉토리의 구성요소
>>>> 디렉토리|설명
>>>> :--|:--
>>>> /|모든 디렉토리가 시작하는 뿌리인 최상위 디렉토리<br>루트라고 읽음
>>>> /boot|부팅에 필요한 커널, 초기화 이미지, 부트로더 관련 파일 존재
>>>> /dev|시스템에 설치된 장치(마우스, 모니터, 그래픽 카드, 저장 장치)가 파일 형태로 저장됨
>>>> /etc|시스템 설정 파일을 모아 놓은 디렉토리<br>사용자와 그룹 정보, 파일 시스템 테이블, 네트워크 설정 파일 등 시스템 환경을 결정하는 중요한 파일들 존재
>>>> /bin|사용자가 사용하는 기본적인 명령들이 실행 파일 형태로 저장됨
>>>> /lib|공유 라이브러리 파일들이 저장되어 있음<br>시스템 부팅과 응용 프로그램 실행에 필요한 코드들이 존재
>>>> /home|사용자 계정 생성시 사용자 계정 이름과 동일한 홈 디렉토리가 /home 디렉토리 아래에 생성됨<br>사용자는 각자의 파일을 사용자 홈 디렉토리에 저장함
>>>> /root|루트 계정을 위해 제공되는 홈 디렉토리<br>일반 사용자를 위한 /home 디렉토리와 달리 일반 사용자는 접근하지 못하도록 접근 권한이 설정되어 있음
>>>> /sbin|시스템 관리 명령들이 들어 있는 디렉토리<br>/bin과 달리 일반적으로 루트 권한이 필요한 명령들임
>>>> /tmp|임시로 파일을 생성 또는 삭제하는 공간<br>주로 사용자 프로그램에서 임시로 읽어 들여야 하는 입출력 파일을 저장하는데 사용<br>저장된 파일이 언제 삭제될지 보장할 수 없음
>>>> /var|시스템을 운영하면서 생기는 각종 임시 파일(시스템 로그, 웹 사이트 콘텐츠, 전자 메일 등)을 저장하는 디렉토리<br>크기가 계속해서 변하는 파일을 저장함
>>>> /usr|일반적으로 사용자가 추가로 설치한 응용 프로그램 파일이 저장됨
>>>> /proc|시스템 정보를 제공하는 디렉토리<br>리눅스 커널과 통신하는 가상 파일 시스템 디렉토리로 실제 공간을 차지하지 않음<br>CPU 정보, 인터럽트 목록, 입출력 주소 목록 등 커널이 제공하는 정보가 파일 형태로 제공
>>>> /opt|운영체제 일부가 아닌 외부에서 제공되는 패키지가 설치되는 디렉토리
>- 디렉토리 다루기
>>- $ pwd
>>>- 현재 작업하고 있는 디렉토리 위치를 출력
>>- $ mkdir emptydir
>>>- 빈 디렉토리를 생성
>>- $ mkdir -p class/student01
>>>- -p(--parents) 옵션은 상위 디렉토리를 포함하는 하위 디렉토리를 생성
>>>- mkdir을 두 번 실행할 필요없이 -p 옵션으로 한번에 생성 할 수 있음
>>- $ cd [옵션] [디렉토리]
>>>- 작업 디렉토리를 이동
>>>- $ cd .. : 상위 디렉토리로 이동
>>>- $ cd : 대상 디렉토리를 입력하지 않으면 해당 사용자 계정의 홈 디렉토리로 바로 이동
>>>- $ cd ~ : 홈 디렉토리를 의미하는 틸트(~)를 사용해도 홈 디렉토리로 이동
>>- $ rmdir [디렉토리]
>>>- 디렉토리를 삭제
>>>- 비어 있는 디렉토리만 삭제
>>>- $ rm -rf [파일/디렉토리]
>>>>- 파일이든 디렉토리이든 디렉토리가 비어있지 않아도 전부 삭제
>- 파일 다루기
>>- $ cp [옵션] [원본파일] [사본파일]
>>>- 파일을 복사
>>>- $ cp sample class/student01/eng : 원본 또는 사본의 경로를 구체적으로 지정할 수 있음
>>>- $ cp -ar sample class/student01/eng
>>>>- -r (--recursive) 옵션을 붙이면 하위 디렉토리에 존재하는 디렉토리와 피일을 모두 복사
>>>>- -a (--archive) 옵션은 파일을 복사하는 과정에서 접근 권한과 소유자, 그룹, 파일 수정 시간 정보를 그대로 보존
>>- $ mv [옵션] [원본파일] [사본파일]
>>>- 파일을 이동하는 명령
>>>- cp와 달리 원본 파일이 삭제됨
>>>- $ mv stu1 stu2 stu3 stu4 middle/class
>>>>- 원본 파일 여러개를 동시에 옮기는 것도 가능함
>>>- mv로 디렉토리도 옮길 수 있으며 옮기려는 디렉토리 경로가 같으면 디렉토리 이름을 바꿈
>>>>- 디렉토리 이름을 바꾸는 명령이 따로 존재하지 않아 mv를 통해 변경함
>>- $ rm -rf
>>>- 하위 디렉터리를 포함한 모든 파일을 삭제할 수 있음
>>>- -f : 삭제하려는 파일이 있는지 확인하지 않고 강제로 삭제하는 옵션
>>>- 대상 파일을 삭제할 권한이 없다면 오류 메시지 표시
>>>- 루트 권한을 얻은 상태에서 rm 명령을 실행시 모든 파일을 삭제할 수 있으나 루트(/) 디렉토리를 삭제할 경우 시스템 파일들이 모두 삭제되어 복구가 불가능하므로 rm 명령을 남용하면 안됨
>- 파일 내용 확인하기
>>- $ cat [파일명]
>>>- 파일 내용을 화면에 출력
>>>- $ cat -n [파일명] : 파일 내용에 줄 번호를 합께 출력
>>- $ cat > [파일명]
>>>- 출력 재지정 기호 > 를 이용하여 출력 결과를 화면 대신 파일로 보내 새로운 파일을 생성
>>>- 명령 실행 시 빈 줄이 나오는데, 이곳에 파일 내용을 입력 후 Ctrl + d 를 통해 입력 종료
>>- 입출력 재지정
>>>- 리눅스의 표준 입력 장치는 키보드, 표준 출력 장치는 모니터 화면임
>>>- \> 또는 < 로 표준 입력 및 출력을 다른 대상으로 변경할 수 있음
>>>- $ ls > [파일명]
>>>>- ls 의 출력 결과를 파일로 출력함
>>>- $ sort -r < [파일명]
>>>>- 파일의 내용을 알파벳 역순으로 정렬하여 화면에 출력
>>>>- sort : 입력한 결과를 순서대로 정렬하는 명령
>>>>- -r (--reverse) 옵션은 결과를 역으로 정렬함
>>- $ more [파일명]
>>>- 화면에 표시될 내용을 한 화면씩 스크롤하며 출력
>>>- space 또는 f 키 입력시 다음 화면으로 이동함
>>>- b 입력시 이전 화면으로 이동함
>>>- enter 입력시 한 줄씩 이동함
>>>- q 입력시 종료 후 명령행으로 복귀함
>>- $ less [파일명]
>>>- more보다 less가 유용함
>>>- more 명령의 단축키 모두 사용 가능
>>>- g 입력시 가장 첫 화면으로 이동함
>>>- shift+g 입력시 가장 마지막 화면으로 이동함
>>>- /[검색어] 입력시 검색 가능
>>>>- n 입력시 다음 검색된 문자열로 이동
>>>>- shift+n 입력시 이전 검색된 문자열로 이동
>>- $ head [파일명]
>>>- 파일의 처음을 기준으로 파일 내용을 출력함
>>>- 기본적으로 파일의 첫 번째 줄부터 열 번쨰 줄까지 출력함
>>>- $ head -n [줄번호] [파일명]
>>>>- -n (--lines) 옵션을 사용하여 특정 줄까지 출력할 수 있음
>>- $ tail [파일명]
>>>- 파일의 마지막을 기준으로 파일 내용을 출력함
>>>- 기본적으로 파일의 마지막 줄부터 열 번째 줄 까지 출력함
>>>- head 와 마찬가지로 -n (--lines) 옵션 사용 가능
>>>- $ tail -f [파일명]
>>>>- -f (--follow) 옵션은 실시간으로 파일을 모니터링함
>- 파일 검색하기
>>- $ find [탐색 경로] [옵션] [표현식]
>>>- 탐색 경로를 생략하면 현재 작업 중인 디렉토리에서 검색함
>>>- 읽기 권한이 없는 디렉토리는 검색을 건너뜀
>>>>- $ sudo find / -name student01
>>>>>- sudo로 루트 권한을 얻으면 모든 디렉토리를 검색할 수 있음
>>>>>- 루트 디렉토리부터 시작해서 모든 파일을 검색하려면 탐색 경로에 /(루트 디렉토리)를 명시함
>>>- 옵션목록
>>>>옵션|설명
>>>>:--|:--
>>>>-name|파일 이름 검색
>>>>-perm|파일 권한 검색
>>>>-type|파일 종류 검색
>>>>-size|파일 크기 검색
>>>>-links|링크 수 검색
>>>>-user|사용자 ID 검색
>>>>-atime<br>-mtime<br>-ctime|특정 기간 동안 접근, 수정, 변경된 파일 검색<br>-atime은 파일 접근시간 검색<br>-mtime은 파일 내용이 달라진 시간 검색<br>-ctime은 파일 내용과 파일 속성을 변경한 시간 검색
>>>- $ find -type d
>>>>- 디렉토리 목록을 출력함
>>>- $ find . -mtime -1
>>>>- 현재 디렉토리 (.) 를 기준으로 수정한 지 하루가 되지 않은 (-mtime -1) 파일들을 검색함
>>>- $ find . -mtime +7
>>>>- 현재 디렉토리 (.) 를 기준으로 수정한 지 일주일이 넘은 (-mtime +7) 파일들을 검색함
>>>- $ find .. -type f -size +100M
>>>>- 상위 디렉토리 (..) 부터 100MB가 넘는 (-size +100M) 일반 파일 (-type f)을 검색함
>>>- $ find / -maxdepth 2 -name bin
>>>>- 루트 디렉토리 (/) 부터 시작해서 두 단계의 하위 디렉토리 (-maxdepth 2) 까지 bin이라는 이름을 가진 (-name bin) 파일 또는 디렉토리를 검색함
>>>>- /bin, /usr/bin 은 포함하지만 /usr/local/bin 은 제외됨
>>>- $ find /etc -type f -iname *conf
>>>>- /etc 디렉토리에서 대소문자 구분 없이 (-i) conf로 끝나는 (-name *conf) 파일 (-type f) 을 검색함
>>- 파일 이름을 대체하는 메타 문자
>>>- 메타 문자 * 은 모든 문자를 대체함
>>>>- a*b => aaaaaaab, a1234b, a1b
>>>- 메타 문자 ? 은 정확히 1개의 문자만 대체함
>>>>- a?b => a1b, adb, a0b
>>>- 메타 문자 [] 는 괄호 안에 있는 문자를 대체함
>>>>- [A, B, C]_number => A_number, B_number, C_number
>>>>- number[0-9] => number1, number8, number0
>>>>- [A-C]number => Anumber, Bnumber, Cnumber
>>- $ echo $PATH
>>>- 명령행에서 명령 입력시 셸은 환경변수 PATH에 정의된 디렉토리들을 검색하여 실행함
>>>- echo 명령으로 PATH의 내용을 확인할 수 있음
>>- $ which [명령]
>>>- PATH 변수의 디렉토리를 검색해서 명령의 절대경로를 찾아 출력함
>>>- $ which ls
>>- $ whereis [명령]
>>>- 명령과 해당 명령의 소스파일, 매뉴얼 페이지의 경로를 검색
>>- $ grep [옵션] [표현식] [파일명]
>>>- 파일 내용을 검색
>>>- $ grep eng student01
>>>>- 아무 옵션 없이 명령을 실행하면 지정한 파일에서 검색된 문자열을 포함하는 행을 출력
>>>- $ grep eng *
>>>>- 현재 디렉토리에 있는 파일을 모두 검색
>>>- $ grep -r eng *
>>>>- 현재 디렉토리부터 하위 디렉토리를 포함한 모든 파일에서 문자열을 검색
>>>- $ grep -c eng student01
>>>>- 해당 문자열이 포함된 행 수를 출력
>>>>- -c (--count)
>>>- $ grep -n eng student01
>>>>- 해당 문자열이 포함된 행과 행 번호를 함께 출력
>>>- $ grep -i eng student01
>>>>- 대소문자 구분 없이 문자 검색
>>>>- -i (--ignore-case)
>>>- ls -l | grep data
>>>>- 파일 목록을 출력하는 ls -l 결과에 data라는 문자열을 포함한 결과만 출력
>>>>- 일반적으로 grep은 파이프로 다른 명령과 조합해서 결과를 얻는데 유용하게 사용함
>>>- 파이프 ( | )
>>>>- 여러 명령을 동시에 사용하는 도구로 프로세스 사이에 정보를 전달하는 통로 역할을 함
>>>>- 명령A | 명령B
>>>>>- 명령A의 출력을 명령B의 입력으로 보냄
>>>>- $ ls -al | more
>>>>- $ ls -al | sort -r | more

<br>

[목차로 이동](#목차)

>### 프로세스 관리하기
>- 프로세스 개요
>>- 실행 중인 프로그램을 나타내는 추상적인 개념
>>- 우분투 서버는 명령행에서 사용할 수 있는 프로세스 관리 도구를 제공함
>>>  명령|설명
>>>  :--|:--
>>>  ps|프로세스 목록 조회
>>>  top|프로세스 상태와 시스템 자원 정보를 실시간으로 출력
>>>  lsof|프로세스가 사용 중인 파일 목록 출력
>>>  jobs|작업 목록 출력
>>>  bg, fg|프로세스를 백그라운드 또는 포그라운드에서 실행
>>>  kill|프로세스에 신호를 보내 상태를 변경
>- 프로세스
>>- 사용자가 저장 장치에 있는 프로그램을 실행하면 프로그램이 프로세스 상태로 메모리에 적재됨
>>- 프로세스는 계층적으로 구성되며, 프로세스마다 자기 자신을 생성한 부모 프로세스가 존재하며 부모 프로세스의 속성을 상속받음
>>- 부팅 과정에서 리눅스 커널이 시작하는 init은 유일하게 부모 프로세스가 없는 1번, 시스템 초기화 프로세스임
>>- 프로세스는 프로그램을 실행한 사용자와 더불어 각 프로세스를 구분하는 정보를 가짐
>>>- PID
>>>>- 프로세스가 시작할 때 할당받는 유일한 프로세스 식별 번호(Process ID)
>>>- UID
>>>>- 프로세스를 소유하는 사용자 계정을 식별하는 번호(User ID)
>>>>- 프로세스에 대한 사용자 권한을 알 수 있음
>>>- PPID
>>>>- 부모 프로세스의 PID(Parent PID)
>>- 프로세스는 리눅스 커널로 정해진 순서에 따라 CPU를 사용함
>>- 프로세스는 다양한 상태로 변화하므로 시스템 관리자는 프로세스 상태를 확인하고 작업 제어 명령으로 프로세스 상태를 변경할 수 있어야 함
>>>상태|설명
>>>:--|:--
>>>R(Run/Runnable)|CPU를 사용하는 상태와 대기하는 상태
>>>D(in Disk wait)|입출력이 완료될 때까지 대기하는 깨울 수 없는 수면 상태<br>입출력이 끝나면 다시 실행 대기로 전환됨
>>>S(Sleeping)|프로그램 필요에 따라 스스로 대기 중인 수면 상태<br>시간이 경과하거나 특정 이벤트가 발생하면 다시 실행 대기로 전환됨
>>>T(sTopped)|외부 신호로 일시 정지된 상태<br> 또 다른 외부 신호를 수신하면 다시 실행 대기로 전환됨<br>실행을 완료한 프로세스는 부모 프로세스에 종료 신호를 보냄<br>부모 프로세스가 종료 신호를 받아들이면 프로세스가 소멸함
>>>Z(Zombie)|부모 프로세스에 문제가 있어 프로세스의 종료 신호를 수신하지 못하면 좀비 상태로 남음
>- 프로세스 확인하기
>>- $ ps
>>>- 프로세스 목록을 출력
>>>- 옵션 없이 입력 시 현재 로그인한 사용자가 실행하는 프로세스만 출력
>>>- -a : 다른 사용자의 프로세스 상태도 함께 출력
>>>- -x : 화면에 보이지 않는 프로세스까지 모두 출력
>>>- 프로세스 목록 중 대괄호([])로 둘러싸인 프로세스는 커널이 생성한 프로세스임
>>>- -u : 프로세스를 사용한 사용자와 실행 시간을 출력
>>>>출력 필드|설명
>>>>:--|:--
>>>>user|프로세스 소유자 이름
>>>>PID(Process ID|프로세스 식별 번호
>>>>%CPU|프로세스가 CPU를 차지하는 비율
>>>>%MEM|프로세스가 메모리를 점유하는 비율
>>>>VSZ(Virtual Set siZe|리눅스가 프로세스에 할당한 가상 메모리 크기(실제 프로세스가 할당한 가상 메모리를 모두 사용하지는 않음)
>>>>RSS(Resident Set Size)|프로세스가 현재 사용하는 메모리 크기(프로세스 사이에 공유되는 메모리 정보는 제외됨)
>>>>STAT|프로세스의 현재 상태
>>>>START|프로세스가 시작된 시간
>>>>TIME|프로세스의 총 사용 시간
>>>>COMMAND|프로세스를 실행한 명령
>>>- -e : 실행 중인 모든 프로세스를 출력
>>>- -f : 완전한 형식으로 출력
>>>>출력 필드|설명
>>>>:--|:--
>>>>PPID|부모 프로세스의 PID (Parent Process ID)
>>>>C|프로세스의 CPU 점유 상태
>>>>STIME|프로세스가 시작된 시간
>>>>TTY|프로세스가 시작되고 있는 터미널
>>- $ ps f
>>>- 프로세스 사이의 상속 관계를 시각적으로 출력
>>- $ top
>>>- 실시간으로 메모리 점유율, CPU 사용률을 확인할 때 ps -aux보다 유용함
>>>- 개별 프로세스 상태를 확인할 때 ps, 전체적인 프로세스 상태를 확인할 때 top 을 사용함
>>>- 상단에 시스템 가동 시간, 평균 부하, 전체 프로세스 정보, 메모리 상태 등 시스템 상태를 요약하여 출력함
>>>- 하단에 각 프로세스의 정보가 출력됨
>>>>출력 필드|설명
>>>>:--|:--
>>>>PID|프로세스 ID
>>>>USER|프로세스 소유자
>>>>PR|프로세스의 우선순위
>>>>NI|우선순위를 지정하는 nice 값
>>>>VIRT|프로세스가 점유하는 가상 메모리 양 (KB)
>>>>RES|스왑되지 않은 물리 메모리양 (KB)
>>>>SHR|공유 메모리양 (KB)
>>>>S|프로세스 상태
>>>>%CPU|CPU 점유율
>>>>%MEM|메모리 점유율
>>>>TIME+|프로세스가 CPU를 사용한 누적 시간
>>>>COMMAND|프로세스를 실행한 명령
>>>- 5초마다 내용이 업데이트되어 CPU를 가장 많이 점유하는 프로세스부터 순서대로 출력
>>>> 단축키|설명
>>>> :--|:--
>>>> Space<br>Enter|프로세스 목록 갱신
>>>> Shift + p|%CPU (CPU 사용량) 을 기준으로 정렬
>>>> Shift + m|%MEM (메모리 사용량) 을 기준으로 정렬
>>>> Shift + n|PID 순으로 정렬
>>>> Shift + t|TIME+ (CPU 사용 시간) 을 기준으로 정렬
>>>> \<<br>\>|정렬 순서 변경
>>>> q|종료
>- 열린 파일 목록 조회하기
>>- $ lsof
>>>- 사용자 명령 또는 시스템 프로세스로 사용중인 파일 목록을 화면에 출력
>>>- 리눅스 커널은 파일을 파일 기술자 (file descriptor) 라는 숫자 값으로 구분함
>>>- 리눅스는 모든 것을 파일로 추상화해서 다루기 때문에 일반 파일 뿐만 아니라 실행 중인 프로세스와 관련된 시스템 장치를 파일 기술자로 관리함
>>>- 파일 기술자
>>>>- 0은 표준 입력
>>>>- 1은 표준 출력
>>>>- 2는 표준 오류
>>>- 출력 내용
>>>> 출력 필드|설명
>>>> :--|:--
>>>> COMMAND|실행한 명령
>>>> PID|프로세스 식별 번호
>>>> USER|사용자
>>>> FD|파일 기술자<br>숫자<br>cwd(현재 작업 디렉토리)<br>rtd(루트 디렉토리)<br>txt(텍스트 파일)<br>mem(메모리 매핑 파일) 로 표시
>>>> TYPE|파일 종류<br>DIR(디렉토리)<br>REG(일반 파일)<br>CHR(문자 장치 파일)<br>FIFO(파이프나 소켓)<br>IPv4(네트워크 연결) 로 표시
>>>> DEVICE|장치 번호
>>>> SIZE/OFF|파일 크기
>>>> NODE|노드 번호
>>>> NAME|파일 이름
>>>- 일부 파일은 사용자 권한으로 조회할 수 없어 표시되지 않지만 sudo 명령을 통한 루트 권한으로 시스템 파일까지 확인할 수 있음
>>- $ lsof -i
>>>- 네트워크 연결 정보 출력
>>>- TCP정보 출력 형식
>>>>- [호스트명]:[포트 번호]->[원격 호스트명]:[포트 번호]
>>>- $ lsof -i [프로토콜]:[포트 번호]
>>>>- 프로토콜과 포트 번호로 결과를 필터링하여 출력
>>- $ lsof -u [사용자 계정]
>>>- 사용자 소유의 열린 파일 목록 출력
>>- $ lsof -c [명령]
>>>- 명령에 쓰이는 파일 목록 출력
>>- $ sudo lsof -p [PID]
>>>- 프로세스가 사용하는 파일목록 출력
>- 작업 제어하기
>>- 여러 작업을 동시에 처리하는 데 작업 제어 명령을 사용함
>>- 일반적으로 실행한 프로세스가 종료될 때까지 사용자가 기다려야 하지만, 프로세스를 백 그라운드에서 실행하면 프롬프트가 나타나 곧바로 다음 명령을 실행할 수 있음
>>- $ wget [옵션] [URL링크]
>>>- 네트워크를 사용하여 파일을 받아옴
>>- $ jobs
>>>- 작업 목록을 화면에 출력
>>>- -l : 해당 프로세스의 PID를 함께 출력
>>- 추가 입력 없이 프로세스를 오랫동안 실행해야 한다면 프로세스가 종료될 떄까지 다른 작업을 처리할 수 있도록 해당 프로세스를 백그라운드에서 실행
>>- $ bg %[작업 ID]
>>>- 중단된 프로세스를 백그라운드에서 실행
>>- $ fg %[작업 ID]
>>>- 백그라운드에서 진행 중인 작업을 다시 포그라운드로 가져옴
>>- $ [명령] &
>>>- 프로세스를 백그라운드에서 처리하도록 명령 뒤에 &를 입력
>>>- 명령이 실행되자마자 프로세스의 작업 ID와 PID가 출력되며, 다른 명령을 입력할 수 있는 상태가 됨
>- 프로세스 상태 변경하기
>>- kill
>>>- 프로세스에 일정한 신호를 보내는 명령
>>>- 실행중인 프로세스에 시스템 신호를 보내 프로세스 상태를 변경
>>- $ kill -l (--list)
>>>- 신호 종류를 출력
>>- $ kill [옵션] [PID]
>>>- 아무 옵션이 없으면 15번 SIGTERM 신호를 보내 프로세스를 종료
>>>- $ kill -9 [PID]
>>>>- 9번 신호 SIGKILL : 프로세스를 강제 종료 신호
>>>- $ kill -1 [PID]
>>>>- 1번 신호 SIGHUP : 프로세스를 멈추지 않고 다시 실행
>>>>- 환경 설정을 변경해서 서비스를 다시 실행할 때 사용
>- 명령 히스토리를 이용한 입력
>>- $ history
>>>- 이전에 자신이 실행했던 명령 목록 출력
>>- $ history | grep [명령]
>>>- 검색하고 싶은 명령만 검색
>>- $ !!
>>>- 바로 전에 실행한 명령을 다시 실행
>>- $ ![번호]
>>>- history 번호에 해당하는 명령을 다시 실행

<br>

[목차로 이동](#목차)

>### 패키지 관리하기
>- 개요
>>- 리눅스 배포판 제조업체는 소프트웨어를 자기만의 고유한 방식으로 관리할 수 있도록 패키지 형태로 묶어 제공함
>>- 우분투는 확장자가 deb인 데비안을 기반으로 하는 패키지 시스템을 사용
>- 기본 패키지 관리 명령 dpkg (Debian PacKaGe)
>>- $ dpkg [옵션] [명령]
>>> 자주 사용하는 명령|설명
>>> :--|:--
>>> -i (--install)|패키지를 설치하거나 최신 버전으로 업그레이드
>>> -r (--remove)|설정 파일은 그대로 두고 패키지를 삭제
>>> -P (--purge)|패키지와 함께 설정 파일까지 모두 삭제
>>> -C (--audit)|패키지가 제대로 설치되었는지 확인
>>> -s (--status)|패키지 상태 정보를 출력
>>> -L (--listfiles)|패키지에 들어 있는 파일과 경로 출력
>>> -l (--list)|패키지 설치 정보 출력
>- 향상된 패키지 관리 도구 apt
>>- 패키지 의존 문제
>>>- 어떤 패키지를 설치하고자 할 때 또 다른 패키지가 필요한 경우
>>>- 문제를 해결하고자 패키지 저장소가 도입됨
>>- 패키지 저장소
>>>- 새로만든 패키지를 패키지 저장소에 올리면 누구나 패키지 저장소에 접근해서 내려받아 설치할 수 있고, 필요한 추가 패키지는 자동으로 검색해서 함께 설치함
>>>- 패키지 저장소에서 필요한 패키지를 검색, 내려받기, 설치, 업그레이드 하는 기본적인 도구가 apt (Advanced Package Tool)
>>- $ apt [명령] [옵션] [패키지]
>>> 명령|설명
>>> :--|:--
>>> update|sources.list 에서 패키지 목록을 얻어옴
>>> upgrade|시스템에 설치되어 있는 패키지를 최신 버전으로 업그레이드
>>> full-upgrade|시스템에 설치되어 있는 패키지를 업그레이드하며, 의존 관계에 있는 패키지를 추가로 설치하거나 삭제
>>> install|패키지 설치<br>다른 패키지가 추가로 필요하면 함께 설치할지 물어본 뒤 설치<br>설치되어 있는 패키지 버전이 낮다면 업그레이드
>>> remove|패키지 삭제
>>> purge|패키지와 함께 관련 설정 파일도 모두 삭제
>>> autoremove|사용하지 않는 불필요한 패키지 제거
>>> search|패키지 검색
>>> show|패키지 정보를 살세하게 출력
>>- 일반적인 apt 를 이용한 패키지 설치 과정
>>>1. 설치하려는 패키지가 우분투 공식 패키지 저장소에 존재하지 않으면
>>>2. 패키지 저장소의 주소를 소스 리스트 (/etc/apt/sources.list) 에 추가
>>>3. apt update 명령으로 패키지 저장소에서 패키지 목록을 받아옴
>>>4. apt install 명령으로 패키지 설치
>>- $ sudo apt update
>>>- 패키지를 설치하기 전에 패키지 목록을 갱신
>>- $ apt search [패턴]
>>>- 패턴이 포함된 패키지 이름을 검색
>>- $ apt show [패키지이름]
>>>- 설치하려는 패키지 정보를 자세하게 출력
>>- $ sudo apt install -y [패키지이름]
>>>- 패키지 설치
>>- $ sudo apt remove [패키지이름]
>>>- 패키지 삭제
>>- $ sudo apt purge [패키지이름]
>>>- 패키지 삭제 과정에서 설정 파일이나 임시로 사용하던 파일이 일부 남겨질 수 있는데, 완전히 삭제
>>- $ sudo apt autoremove
>>>- 제거한 패키지와 의존 관계에 있어 더 이상 필요 없게 된 패키지들 삭제
>>- $ sudo apt list --upgradable
>>>- 업데이트 가능한 패키지 출력
>>- $ sudo apt upgrade
>>>- 업데이트 가능한 모든 패키지를 갱신

<br>

[목차로 이동](#목차)

>### 서비스 관리하기
>- 시스템 관리자 systemd
>>- 부팅과정
>>>1. BIOS/UEFI 가 파티션 정보를 읽고 부트로더 GRUB 실행
>>>2. GRUB 가 저장 장치에서 커널을 찾아 메모리에 올리고 시스템 제어 권한을 커널에 넘김
>>>3. 커널은 시스템 초기화 이미지인 initrd (INITial Ram Disk)를 메모리에 마운트
>>>>- initrd 에는 장치 드라이버를 비롯한 시스템 초기화 도구들이 들어 있음
>>>4. 커널은 필요한 도구를 실행하고 저장 장치의 진짜 루트 파일 시스템을 마운트
>>>5. 리눅스 커널은 모든 프로세스의 부모 역할을 하는 PID 1번 프로세스 init을 실행
>>>6. init은 시스템 초기화를 하여 사용자가 시스템을 사용할 수 있는 환경을 만듬
>>- $ ls -al /sbin/init
>>>- /sbin/init 은 systemd의 심벌릭 링크임
>>>- 최신 우분투는 과거에 사용되던 SystemV 형식의 시스템 초기화 프로세스 init 대신 systemd를 사용함
>>- systemd는 부팅 프로세스만 처리하지 않고 시스템을 전반적으로 관리하는 만능 도구로 개발됨
>>>- 예전 시스템과 호환성을 유지하기 위해 /sbin/init 을 유지시킴
>>>- 시스템 자원을 기능에 따라 유닛이라는 단위로 세분화시켜 관리함
>>>- 어떤 유닛을 어떤 순서로 활성화할지 결정되면 systemd가 부팅 과정에서 해당 유닛을 활성화시킴
>>>- 모든 유닛은 유형에 따라 구분하며, 시스템 관리자가 신경 써야 할 주요 유닛으로 부팅 과정에서 활성화시킬 다른 유닛 목록(target), 시스템이 제공할 서비스(service), 서비스에 할당된 네트워크 소켓(socket), 시스템에 설치된 장치(device), 마운트된 파일 시스템(mount), 스왑 공간(swap) 등이 있음
>- systemctl 로 시스템 상태 조회 하기
>>- $ systemctl [옵션] [명령]
>>>- 시스템 상태를 조회하거나 서비스 제어를 위한 systemd 관리 명령
>>- $ systemctl  list-units
>>>- 유형별 유닛 목록과 상태를 출력
>>>>- UNIT
>>>>>- 유닛이름, 유닛 이름 뒤에 접미사 (automount, device, service 등) 로 유닛의 유형을 짐작할 수 있음
>>>>- LOAD
>>>>>- systemd 가 유닛 설정 파일을 정상적으로 읽어 들였는지 표시
>>>>- ACTIVE
>>>>>- 유닛이 동작하고 있는지 표시
>>>>- SUB
>>>>>- 유닛이 활성 (active) 상태라면 추가 상태 정보를 표시
>>>>- DESCRIPTION
>>>>>- 유닛에 대한 세부 설명
>>- $ systemctl list-units -t [유닛 유형]
>>>- -t (--type) 으로 유닛 유형에 따라 결과를 필터링 할 수 있음
>>- $ systemctl list-dependencies
>>>- 의존 관계에 있는 유닛을 출력
>>- $ systemctl get-default
>>>- 현재 기본 target을 출력
>- systemctl 로 서비스 제어하기
>>- $ systemctl status [서비스]
>>>- 서비스의 상태를 출력
>>- $ systemctl is-active [서비스]
>>>- 서비스가 현재 활성화 상태인지 확인
>>- $ systemctl is-enabled
>>>- 부팅 과정에서 자동으로 활성화되는지 확인
>>- $ sudo systemctl stop [서비스]
>>>- 서비스를 중지
>>- $ sudo systemctl start [서비스]
>>>- 서비스를 시작
>>- $ sudo systemctl restart [서비스]
>>>- 서비스를 다시 시작
>>- $ sudo systemctl disable [서비스]
>>>- 부팅 과정에서 서비스가 자동으로 활성화되지 않도록 함
>>- $ sudo systemctl enable [서비스]
>>>- 부팅 과정에서 서비스가 자동으로 활성화되도록 함
>- journalctl 로 systemd 의 로그 정보 조회하기
>>- 로그 정보
>>>- systemctl status 로 확인할 수 있는 로그 정보는 systemd-journald 가 제공함
>>>- systemd-journald 는 부팅부터 발생하는 systemd 의 로그 정보를 이진 자료로 저장함
>>>- systemd 로그 정보는 이진 자료이기 떄문에 journalctl 명령으로만 확인할 수 있음
>>- $ journalctl -u [유닛]
>>>- -u (--unit) 옵션으로 특정 유닛에 대한 로그 정보를 조회
>>- $ journalctl -eu [유닛]
>>>- -e (--pager-end) 옵션은 최근 로그 정보부터 화면 스크롤을 시작
>>- $ journalctl -u [유닛] -p [로그 수준]
>>>- -p (--priority) 옵션을 붙여 로그 정보를 중요도에 따라 필터링
>>>- 응급(emerg), 경고(alert), 심각(crit), 오류(err), 주의(warning), 알림(notice), 의미 있는 정보(info), 디버그 정보(debug) 순으로 로그 수준을 지정하여 결과를 확인할 수 있음
>>- $ journalctl -u [유닛] -S [년]-[월]-[일] [시]:[분]:[초] -U [ yesterday | today | tomorrow ]
>>>- 날짜나 시간을 기준으로 로그를 필터링
>>>- -S (--since), -U (--until)

<br>

[목차로 이동](#목차)

>### vi 편집기 익히기
>- vim 으로 업데이트
>>- vi는 기본적인 편집 기능만 있어 사용하기 불편한 점이 많으므로 향상된 vi (Vi IMproved) 인 vim을 사용
>>- $ sudo apt update
>>- $ sudo apt install vim
>- vi 모드
>>- 명령 모드
>>>- 텍스트 편집기에서 사용할 수 있는 일반적인 기능을 활용할 수 있는 모드로 커서 이동, 텍스트 삭제, 복사와 붙여넣기 등을 할 수 있음
>>- 입력 모드
>>>- 명령 모드에서 a, i, o 등을 누르면 입력 모드로 전환함
>>>- 실제 텍스트를 입력할 수 있으며 입력을 끝내고 다시 명령 모드로 돌아오려면 Esc를 누름
>>- ex 모드
>>>- 콜론 ( : ) 을 눌러 ex모드로 전환함
>>>- ex 프롬프트를 통해 확장 기능을 활용할 수 있음
>>>- 파일 저장, 편집기 종료, 텍스트 검색, 치환 등을 할 수 있으며 Esc를 누르면 명령 모드로 복귀함
>- 명령 모드에서 사용할 수 있는 키
>>- 커서 이동키
>>>키|설명
>>>:--|:--
>>>h|한 칸 왼쪽으로 이동
>>>l|한 칸 오른쪽으로 이동
>>>j|한 줄 아래로 이동
>>>k|한 줄 위로 이동
>>>w|다음 단어의 첫 글자로 이동, 각 특수 문자를 단어로 취급
>>>W|다음 단어의 첫 글자로 이동, 공백 단위로 이동
>>>b|이전 단어의 첫 글자로 이동, 각 특수 문자를 단어로 취급
>>>B|이전 단어의 첫 글자로 이동, 공백 단위로 이동
>>>e|다음 단어의 마지막 글자로 이동, 각 특수문자를 단어로 취급
>>>E|다음 단어의 마지막 글자로 이동, 공백 단위로 이동
>>>^|커서가 있는 줄의 처음으로 이동
>>>$|커서가 있는 줄의 마지막으로 이동
>>>Enter|다음 줄의 첫 글자로 이동
>>>}|다음 문단으로 이동
>>>{|이전 문단으로 이동
>>>)|다음 문장으로 이동
>>>(|이전 문장으로 이동
>>>gg|파일 처음 위치로 이동
>>>G|파일 마지막 위치로 이동
>>- 텍스트 입력키
>>>키|설명
>>>:--|:--
>>>a|커서 위치의 다음 칸부터 입력
>>>A|커서가 있는 줄의 끝부터 입력
>>>i|커서 위치부터 입력, insert도 같은 기능
>>>I|커서가 있는 줄의 맨 앞에서부터 입력
>>>o|커서 바로 아래에 줄을 만들고 입력
>>>O|커서 바로 위에 줄을 만들고 입력
>>- 텍스트 삭제키
>>>키|설명
>>>:--|:--
>>>x|커서 위치의 글자 삭제
>>>X|커서 바로 앞의 글자 삭제
>>>dh|커서 바로 앞의 글자 삭제, X와 같음
>>>dl|커서 위치의 글자 삭제, x와 같음
>>>dj|커서가 있는 줄과 그 다음 줄을 삭제
>>>dk|커서가 있는 줄과 그 앞줄을 삭제
>>>dw|한 단어를 삭제
>>>d0|커서 위치부터 줄의 처음까지 삭제
>>>d$|커서 위치부터 줄의 끝까지 삭제
>>>D|d$과 같음
>>>dd|커서가 있는 줄을 삭제
>>>dgg|커서가 있는 위치부터 파일 처음 위치까지 모두 삭제
>>>dG|커서가 있는 위치부터 파일 마지막 위치까지 모두 삭제
>>- 텍스트 수정키
>>>키|설명
>>>:--|:--
>>>r|커서 위치의 한 글자 수정
>>>R|커서 위치부터 esc를 누를 때까지 다른 글자로 수정, 단 같은 줄에만 해당
>>>s|커서 위치의 한 글자를 지우고 입력 모드에서 수정
>>>S|커서가 있는 줄을 지우고 입력 모드에서 수정
>>>ch|커서 바로 앞의 한 글자를 지우고 입력 모드에서 수정, S와 같음
>>>cl|커서 위치의 한 글자를 지우고 입력 모드에서 수정, s와 같음
>>>cj|커서가 있는 줄과 그 다음 줄을 수정
>>>ck|커서가 있는 줄과 그 앞줄을 수정
>>>cw|커서 위치부터 한 단어를 수정
>>>c0|커서 위치부터 줄의 처음을 지우고 입력 모드에서 수정
>>>c$|커서 위치부터 줄의 끝가지 지우고 입력 모드에서 수정
>>>C|c$와 같음
>>>cc|커서가 있는 줄을 지우고 입력모드에서 수정
>>>J|커서가 있는 줄과 다음 줄을 연결
>>- 텍스트 복사키
>>>키|설명
>>>:--|:--
>>>yw|커서 위치부터 단어 끝까지 복사
>>>y0|커서 위치부터 줄의 처음까지 복사
>>>y$|커서 위치부터 줄의 끝까지 복사
>>>yy|커서가 있는 줄을 복사
>>>yj|커서가 있는 줄과 그 다음 줄을 복사
>>>yk|커서가 있는 줄과 그 앞줄을 복사
>>>p|커서의 다음 위치에 붙여넣기
>>>P|커서가 있는 위치에 붙여넣기
>>- 작업 취소, 반복키
>>>키|설명
>>>:--|:--
>>>u|작업 취소
>>>U|그 줄에 행해진 작업 모두 취소
>>>Ctrl + r|다시 실행
>>>.|조금 전에 했던 명령 반복
>>- 텍스트 검색키
>>>키|설명
>>>:--|:--
>>>/[검색어]|현재 커서를 기준으로 후방 텍스트 검색
>>>?[검색어]|현재 커서를 기준으로 전방 텍스트 검색
>>>n|같은 방향으로 검색할 텍스트를 계속 검색
>>>N|반대 방향으로 검색할 텍스트를 계속 검색
>>- 영역 선택키
>>>키|설명
>>>:--|:--
>>>v|커서가 위치한 곳부터 블록 지정
>>>V|커서가 있는 줄부터 블록 지정
>- ex 모드에서 사용할 수 있는 명령
>>- 파일 저장, 편집기 종료키
>>>키|설명
>>>:--|:--
>>>:q|아무런 변경을 하지 않았을 때 종료
>>>:q!|변경된 내용을 저장하지 않고 강제 종료
>>>:wq|저장하고 종료
>>>:x|wq와 같은 기능
>>>:w [새 이름]|새 이름으로 파일 저장
>>- 유용한 ex 명령
>>>키|설명
>>>:--|:--
>>>:sh|셀을 실행<br>exit 명령 또는 Ctrl + D 를 눌러 vim으로 복귀
>>>:15|행 번호 15로 이동
>>>:r [파일명]|파일 내용을 읽어 현재 위치 아래에 삽입
>>>:10,20w [파일명]|10번부터 20번 줄까지 파일에 쓰기
>>>:10,20d [파일명]|10번부터 20번 줄까지 삭제
>>>:0,$-4d|0번부터 끝에서 네 줄까지 제외하고 모두 삭제
>>>:20,25y|20번부터 25번 줄까지 복사
>>>:10,15m40|10번부터 15번 줄까지 40번 줄 아래로 옮김
>>>:10,15co40|10번부터 15번 줄까지 40번 줄 아래로 복사
>>>:s/abc/def|커서 위치부터 줄 끝까지 처음 나오는 문자열 abc를 찾아 def로 변경
>>>:10,15s/abc/def|10번부터 15번 줄까지 처음 나오는 문자열 abc를 def로 변경
>>>:s/abc/def/g|커서 위치부터 줄 끝까지 모든 문자열 abc를 def로 변경
>>>:%s/abc/def/g|파일 전체에서 문자열 abc를 def로 변경
>>>:g/abc/m0|파일에서 문자열 abc를 포함하는 줄을 찾아 맨 위로 옮김
>>>:v/abc/m0|파일에서 문자열 abc를 포함하지 않는 줄을 찾아 맨 위로 옮김
>>>:10,15g/abc/m0|10번부터 15번 줄까지 문자열 abc를 포함하는 줄을 찾아 맨 위로 옮김
>>- vi 환경 설정 내용을 변경하는 set 명령
>>>키|설명
>>>:--|:--
>>>:set number|줄마다 행 번호를 보이도록 설정<br>해제시 set nonumber
>>>:syntax on|구문 강조 기능 사용
>>>:set autoindent|자동 들여쓰기 기능 사용
>>>:set smartindent|똑똑한 들여쓰기 기능 사용
>>>:set cindent|C 프로그램 들여쓰기 기능을 사용
>>>:set shiftwidth=4|들여쓰기를 4칸으로 설정
>>>:set expandtab|Tab을 누르면 공백을 삽입
>>>:set tabstop=4|기본적으로 탭 간격은 8칸인데 4칸으로 변경
>>>:set paste|터미널에서 붙여넣을 때 자동 들여쓰기를 활성화
>>>:set hlsearch|/나 ?로 검색한 텍스트를 강조<br> 해제시 :nohl
>>>:set showmatch|일치하는 괄호를 강조
>>>:set ruler|현재 커서 위치를 표시
>>>- set 명령을 별도의 설정파일 .vimrc 로 저장해 두면 나만의 vim 환경을 만들 수 있음
>- [Vim adventures](http://vim-adventures.com) 는 vi 사용법을 익히는데 도움되는 웹 브라우저 기반 게임
>- 셸 스크립트
>>```bash
>>#!/bin/bash
>>
>>result=syslogresult`date +%y%m%d`
>>line="${1:-10}"
>>
>>if [[ "$1" -gt 30 ]]; then
>>    echo "too big"
>>    exit 1
>>fi
>>
>>tail /var/log/syslog -n"$line" > "$result"
>>
>>exit 0
>>```
>>- #!/bin/bash
>>>- 모든 배시 셸 스크립트는 #!/bin/bash 로 시작해야 함
>>- result=syslogresult\`date +%y%m%d`
>>>- 변수를 선언할 수 있으며 `` 을 사용하여 명령을 실행할 수 있음
>>- line="\${1:-10}"
>>>- ${변수:-기본값} 은 해당 변수가 없으면 변수에 기본값을 저장함
>>```bash
>>if [[ "$1" -gt 30 ]]; then
>>    echo "too big"
>>    exit 1
>>fi
>>```
>>>- 흐름 제어도 사용할 수 있으며 대괄호 안에 조건을 입력함
>>- tail /var/log/syslog -n"\$line" > "\$result"
>>>- 변수를 사용할 때는 변수 이름 앞에 $를 입력하여 사용
>>- $ sudo cp sysloger /usr/local/bin/
>>>- 일반적으로 사용자가 작성한 스크립트는 /usr/local/bin 에 저장하며, 셸 스크립트를 이동시키면 아무 곳에서나 실행할 수 있음

<br>

[목차로 이동](#목차)

---

## 리눅스 가상 시스템

>### 리눅스 가상 시스템이란
>- 