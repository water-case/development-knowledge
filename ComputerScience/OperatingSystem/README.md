# **OperatingSystem** 💿

### 참고자료

- Operating System Concepts 10E

## 목차
>- [개요](#개요)
>>- [운영체제가 할일](#운영체제가-할일)
>>- [컴퓨터 시스템의 구성](#컴퓨터-시스템의-구성)
>>- [컴퓨터 시스템 구조](#컴퓨터-시스템-구조)
>>- [운영체제의 작동](#운영체제의-작동)
>>- [자원 관리](#자원-관리)
>- [운영체제 구조](#운영체제-구조)
>>- [운영체제 서비스](#운영체제-서비스)
>>- [사용자와 운영체제 인터페이스](#사용자와-운영체제-인터페이스)
>>- [시스템 콜](#시스템-콜)
>>- [링커와 로더](#링커와-로더)
>>- [운영체제의 구조](#운영체제의-구조)

<br>

---

## 개요

>### 운영체제가 할일
>- 컴퓨터 하드웨어를 관리하는 소프트웨어로 응용 프로그램을 위한 기반을 제공하며 컴퓨터 사용자와 컴퓨터 하드웨어 사이에서 중재자 역할
>- 운영체제의 역할을 이해하려면 컴퓨터 하드웨어 구성과 구조의 이해가 필요
>>- 운영체제의 근본적인 책임은 CPU, 메모리 및 입출력 장치와 저장장치와 같은 자원들을 프로그램에 적절히 할당하는 것
>>>- 자원 할당자라고 볼 수 있음
>>>- 컴퓨터의 부적절한 사용을 방지하기 위해 사용자 프로그램의 수행을 제어하고 특히 입출력 장치의 제어와 작동에 깊이 관여함
>- 운영체제의 구성
>>- 커널
>>>- 컴퓨터에서 항상 실행되는 프로그램
>>- 시스템 프로그램
>>>- 운영체제와 관련되어 시스템을 관리하는 데 도움이 되는 프로그램
>>- 미들웨어 프레임워크
>>>- 응용 프로그램 개발을 쉽게하도록 도와주는 기능을 제공하는 프로그램

<br>

[목차로 이동](#목차)

>### 컴퓨터 시스템의 구성
> 하나 이상의 CPU, 구성요소와 공유 메모리 사이의 엑세스를 제공하는 공통 버스를 통해 연결된 여러 장치 컨트롤러로 구성됨
>- 장치 컨트롤러
>>- 일부 로컬 버퍼 저장소와 특수 목적 레지스터 집합을 유지 관리함
>>- 제어하는 주변 장치와 로컬 버퍼 저장소 간 데이터를 이동함
>>- 일반적으로 운영체제에는 각 장치 컨트롤러마다 장치 드라이버가 있음
>>- CPU와 장치 컨트롤러는 병렬로 실행되어 메모리 사이클을 놓고 경쟁함
>>- 공유 메모리를 질서 있게 엑세스하기 위해 메모리 컨트롤러는 메모리에 대한 액세스를 동기화함
>- 인터럽트
>>- CPU의 조치가 필요한 이벤트에 대해 경고
>>- 컨트롤러는 장치 드라이버에게 작업을 완료했다는 사실을 인터럽트를 통해 알림
>>- 이외 많은 목적으로 사용되며 운영체제와 하드웨어의 상호 작용 방식의 핵심 부분임
>>- 긴급한 작업을 먼저 수행하기 위해 인터럽트 우선순위 시스템을 사용함
>- 저장장치
>>- CPU는 메모리에서만 명령을 적재할 수 있음
>>>- 실행하려면 프로그램을 메모리에 적재해야 함
>>>- 범용 컴퓨터는 프로그램 대부분을 재기록 가능한 메인 메모리(RAM)에서 가져옴
>>>>- 메인 메모리는 DRAM 이라 불리는 반도체 기술로 만들어짐
>>- 모든 형태의 메모리는 바이트의 배열을 제공함
>>>- 각 바이트는 자신의 주소를 가지고 있음
>>>- 상호 작용은 특정 메모리 주소들에 대한 일련의 적재(load), 또는 저장(store)명령을 통해 이루어짐
>>- 폰 노이만 구조 시스템의 명령-실행 사이클
>>>1. 메모리로부터 명령을 인출하여 명령 레지스터(instuction register)에 저장
>>>2. 명령을 해독
>>>>- 메모리로부터 피연산자를 인출하여 내부 레지스터에 저장하도록 유발할 수 있음
>>>>- 피연산자에 대한 명령을 실행한 후의 결과가 다시 메모리에 저장될 수 있음
>>- 대부분의 컴퓨터 시스템은 메인 메모리의 확장으로 보조저장장치를 제공
>>>- 보조저장장치는 대량의 데이터를 영구히 보존할 수 있어야 함
>- 입출력구조
>>- 운영체제 코드의 상당 부분은 시스템의 안정성과 성능에 대한 중요성과 장치의 다양한 특성으로 인해 I/O 관리에 할애됨

<br>

[목차로 이동](#목차)

>### 컴퓨터 시스템 구조
>- 단일 처리기 시스템
>>- 코어
>>>- 명령을 실행하고 로컬로 데이터를 저장하기 위한 레지스터를 포함하는 구성요소
>>>- 코어를 가진 하나의 메인 CPU는 프로세스의 명령어를 포함한 범용 명령어 세트를 실행할 수 있음
>>- 단일 처리 코어를 가진 범용 CPU가 하나만 있는 경우 단일 프로세서 시스템임
>- 프로세서와 프로세스
>>- 프로세서: 컴퓨터 내에서 프로그램을 수행하는 하드웨어 유닛으로써 CPU를 뜻하고, 폰노이만 아키텍처에 의해 만들어 졌다면 적어도 하나 이상의 ALU와 처리 레지스터를 내장함
>>- 프로세스: 메모리에 적재되어 프로세서에 의해 실행중인 프로그램
>- 다중 처리기 시스템
>>- 단일 코어 CPU가 두 개 이상의 프로세서가 있는 시스템
>>- 주요 장점으로 처리량 증가
>>>- 프로세서 수를 늘리면 더 적은 시간에 더 많은 작업을 수행
>>>- BUT, 여러 프로세서가 하나의 작업에 협력할 때 모든 프로세서가 올바르게 작동하기위한 일정 양의 오버헤드 발생
>>>- 오버헤드와 공유 자원에 대한 경합은 추가 프로세서의 예상 이득을 낮춤
>- 클러스터형 시스템
>>- 저장장치를 공유하고 근거리 통신망(LAN)이나 InfiniBand와 같은 고속의 상호 연결망으로 연결됨
>>- 높은 가용성을 제공함

<br>

[목차로 이동](#목차)

>### 운영체제의 작동
>- 작동 전반
>>1. 정원을 켜거나 재부팅 할 때와 같이 컴퓨터를 실행하려면 부트스트랩 프로그램을 실행해야 함
>>>- 단순한 형태를 띄는 경향이 있고, 일반적으로 컴퓨터 하드웨어 내에 펌웨어로 저장됨
>>2. CPU 레지스터에서 장치 컨트롤러, 메모리 내용에 이르기까지 시스템의 모든 측면을 초기화함
>>3. 부트스트랩 프로그램이 운영체제 커널을 찾아 메모리에 적재
>>4. 커널이 적재되어 실행되면 시스템과 사용자에게 서비스를 제공할 수 있음
>>5. 실행할 프로세스, 서비스할 I/O 장치 및 응답할 사용자가 없는 경우 대기하다가 인터럽트에 의해 이벤트가 발생됨
>- 다중 프로그래밍과 다중 태스킹
>>- 다중 프로그래밍
>>>- CPU가 항상 한 개는 실행할 수 있도록 프로그램을 구성하여 CPU 이용률을 높이고 사용자 만족도를 높임
>>>- 다중 프로그램 시스템에서 실행 중인 프로그램을 프로세스라 함
>>>- 운영체제는 동시에 여러 프로세스를 메모리에 유지함
>>- 다중 태스킹
>>>- 다중 프로그래밍의 논리적 확장으로 CPU를 여러 프로세스를 전환해가며 프로세스를 실행
>>>- 전환이 자주 발생하여 사용자에게 빠른 응답 시간을 제공할 수 있음
>>>- CPU 스케줄링으로 실행할 프로세스가 정해지며 여러 프로세스를 병행하게 실행하려면 운영체제의 모든 단계에서 서로 영향을 미치는 기능이 제한되어야 함
>>>- 다중 태스킹 시스템에서 운영체제는 적절한 응답 시간을 보장해야함
>- 이중 모드와 다중 모드 운용
>>- 시스템을 올바르게 실행하려면 운영체제 코드 실행과 사용자 정의 코드 실행을 구분해야함
>>>- 대부분의 컴퓨터 시스템이 다양한 실행 모드를 차별화 할 수 있는 하드웨어지원을 제공함
>>>- 적어도 사용자 모드와 커널 모드(수퍼바이저 모드, 시스템 모드, 혹은 특권 모드)를 필요로 함

<br>

[목차로 이동](#목차)

>### 자원 관리
>- 시스템의 CPU, 메모리 공간, 파일 저장 공간 및 I/O 장치는 운영체제가 관리해야 하는 자원임
>- 프로세스 관리
>>- 프로세스는 자기 일을 수행하기 위해 CPU 시간, 메모리, 파일, 그리고 입출력 장치를 포함한 여러 가지 자원을 필요로 하고 실행되는 동안 할당됨
>>- 하나의 프로그램은 디스크에 저장된 파일의 내용과 같이 수독적 개체지만 프로세스는 다음 수행할 명령을 지정하는 Program Counter를 가진 능동적 개체임
>>- 다중 스레드 프로세스는 여러 개의 프로그램 카운터를 가지고 있으며 이 카운터들은 각 스레드가 실행할 다음 명령어를 가리킴
>>- 한 프로세스는 한 시스템 내의 작업의 단위이며 시스템은 프로세스의 집합으로 구성됨
>>- 운영체제의 프로세스 관리 책임
>>>- 사용자 프로세스와 시스템 프로세스의 생성과 제거
>>>- CPU에 프로세스와 스레드 스케줄
>>>- 프로세스의 일시 중지와 재수행
>>>- 프로세스 동기화를 위한 기법 제공
>>>- 프로세스 통신을 위한 기법 제공
>- 메모리 관리
>>- 운영체제의 메모리 관리 책임
>>>- 메모리의 어느 부분이 현재 사용되고 있으며 어느 프로세스에 의해 사용되고 있는지 추적
>>>- 필요에 따라 메모리 공간을 할당 및 회수
>>>- 어떤 프로세스를 메모리에 적재하고 제거할 것인지 결정
>- 파일 시스템 관리
>>- 운영체제는 저장장치의 물리적 특성을 추상화하여 논리적인 저장 단위인 파일을 정의
>>- 운영체제는 파일을 물리적 매개로 매핑하며, 저장장치를 통해 이 파일들에 접근
>>- 파일은 통상 디렉터리들로 구성됨
>>- 운영체제의 파일 관리 책임
>>>- 파일의 생성 및 제거
>>>- 디렉터리 생성 및 제거
>>>- 파일과 디렉터리를 조작하기 위한 프리미티브 제공
>>>- 파일을 보조저장장치로 매핑
>>>- 안정적인(비휘발성) 저장 매체에 파일을 백업
>- 대용량 저장장치 관리
>>- 운영체제의 보조저장장치 관리 책임
>>>- 마운팅과 언마운팅
>>>- 사용 가능 공간의 관리
>>>- 저장장소 할당
>>>- 디스크 스케줄링
>>>- 저장장치 분할
>>>- 보호

<br>

[목차로 이동](#목차)

---

## 운영체제 구조

>### 운영체제 서비스
>- 프로그램 실행 환경을 제공하는 운영체제는 프로그램과 그 프로그램의 사용자에게 특정 서비스를 제공함
>>- 운영체제마다 제공하는 서비스는 다르지만 공통적인 서비스가 존재함
>- 프로그래밍 작업을 위해 제공하는 서비스의 종류
>>- 사용자 인터페이스
>>>- 거의 모든 운영체제는 사용자 인터페이스(UI)를 제공함
>>>- GUI (그래픽 사용자 인터페이스) / CLI (명령어 라인 인터페이스) 로 나뉨
>>- 프로그램 수행
>>>- 프로그램을 메모리에 적재해 실행할 수 있어야 하며 정상적이든 비정상적이든(오류를 표시하며) 실행을 끝낼 수 있어야 함
>>- 입출력 연산
>>>- 수행 중인 프로그램은 입출력을 요구할 수 있으며 파일 혹은 입출력 장치가 연관됨
>>>- 효율과 보호를 위해 사용자들은 통상적으로 입출력 장치를 직접 제어할 수 없고, 운영체제가 입출력 수행의 수단을 제공해야 함
>>- 파일 시스템 조작
>>>- 프로그램은 파일을 읽고 쓸 필요가 있으며 이름에 의해 파일을 생성하고 삭제할 수 있고 지정된 파일을 찾을 수 있어야 하고 파일의 정보를 열거할 수 있어야 함
>>>- 운영체제는 개인의 선택에 따라 또는 특정 특성과 특정 성능을 제공하기 위해 다양한 파일 시스템을 제공함
>>- 통신
>>>- 서로 다른 프로세스가 정보를 교환해야 할 필요가 있음
>>>- 동일 컴퓨터의 프로세스간 통신, 네트워크를 통해 연결된 서로 다른 컴퓨터 시스템에서 수행되는 프로세스간 통신으로 나뉨
>>>- 통신 구현 방법으로 공유 메모리, 메시지 전달 기법이 존재
>>>>- 메시지 전달 기법에는 정보의 패킷들이 운영체제에 의해 프로세스 사이를 이동
>>- 오류 탐지
>>>- 운영체제는 발생할 수 있는 모든 오류를 의식하고 있어야 함
>>>- CPU, 메모리 하드웨어(메모리 오류, 정전 등), 입출력 장치(테이프의 패리티 오류, 네트워크 접속 실패, 프린터의 종이 부족 등), 사용자 프로그램(연산 오버플로, 불법적 메모리 접근 시도) 등에서 오류가 발생할 수 있음
>- 시스템 자체의 효율적인 동작을 보장하기 위한 운영체제 기능
>>- 다수의 프로세스가 사용하는 시스템에서는 프로세스 간 자원을 공유하게 하여 효율성을 얻을 수 있음
>>- 자원 할당
>>>- 운영체제는 여러 종류의 자원을 관리하며 다수의 프로세스나 다수의 작업이 동시에 진행될 때 각각에 자원을 할당해줘야 함
>>- 기록작성
>>>- 어떤 프로그램이 어떤 종류의 자원을 얼마나 많이 사용하는지 추적할 수 있음
>>>- 기록 관리는 회계(사용자에게 청구서를 보낼 수 있도록), 단순한 사용 통계를 내기 위해 사용됨
>>- 보호와 보안
>>>- 보호는 여러 프로세스가 병행중인 상황에서 특정 프로세스가 다른 프로세스나 운영체제 자체를 방해하지 않도록 시스템 자원에 대한 모든 접근이 통제되도록 보장하는 것을 필요로 함
>>>- 보안은 네트워크 어댑터 등과 같은 외부 입출력 장치들을 부적합한 접근 시도로부터 지키고, 침입의 탐지를 위해 모든 접속을 기록하는 것까지 포함

<br>

[목차로 이동](#목차)

>### 사용자와 운영체제 인터페이스
>- 명령 인터프리터
>>- 운영체제 대부분은 명령 인터프리터를 프로세스가 시작되거나 사용자가 처음 로그온할 때 수행되는 특수한 프로그램으로 취급함
>>- 선택할 수 있는 여러 명령 인터프리터를 제공하는 시스템에서 이 해석기는 셸(shell)이라고 부르며 대부분의 셸은 유사한 기능을 제공함
>>>- 사용자가 지정한 명령을 가져와서 수행하는 것이 주요 기능임
>>>- 제공되는 명령들은 파일을 생성, 삭제, 리스트, 프린트, 복사, 수행 등을 수행함
>>- 명령어들은 두 가지 일반적인 방식으로 구현됨
>>>- 명령 인터프리터 자체가 명령을 실행할 코드를 가지는 경우
>>>- 시스템 프로그램에 의해 대부분의 명령을 구현하는 경우
>>>>- 명령 인터프리터가 명령에 대해 알지 못하며 단순히 메모리에 적재되어 실행될 파일을 식별하기 위해 명령을 사용함
>>>>- 이러한 경우 명령 인터프리터 프로그램이 아주 작아질 수 있으며, 새로운 명령을 추가하기 위해 변경될 필요가 없음
>- 그래픽 기반 사용자 인터페이스
>>- 사용자 친화적인 그래픽 기반 사용자 인터페이스 또는 GUI를 통하는 방식
>>- 데스크톱이라 불리며 마우스를 기반으로하는 윈도우 메뉴 시스템을 이용함
>- 인터페이스의 선택
>>- 컴퓨터를 관리하는 시스템 관리자와 시스템에 대해 깊게 알고 있는 파워유저들은 명령어 라인 인터페이스를 주로 사용함
>>>- 하고자 하는 작업에 더 빨리 접근할 수 있고 GUI에서 사용할 수 없는 기능들을 사용할 수 있음
>>>- 반복적으로 해야하는 작업을 셸 스크립트로 프로그래밍하여 쉽게 할 수 있음
>>- 유용하고 친밀한 사용자 인터페이스를 설계하는 것이 운영체제의 직접적인 기능은 아님

<br>

[목차로 이동](#목차)

>### 시스템 콜
>- 프로세스가 운영체제의 커널이 제공하는 서비스를 요청할 때 사용하는 방법으로 운영체제에 의해 사용 가능하게 된 서비스에 대한 인터페이스를 제공함
>- 시스템 콜의 유형
>>- 프로세스 제어 (Process Control)
>>- 파일 조작 (File Manipulation)
>>- 장치 조작 (Device Management)
>>- 정보 유지 보수 (Information Maintenance)
>>- 통신 (Communication)
>>- 보호 (Protection)

<br>

[목차로 이동](#목차)

>### 링커와 로더
>- 일반적으로 프로그램은 디스크에 이진 실행 파일로 존재하며 CPU에서 실행하려면 메모리로 가져와 프로세스 형태로 배치되어야 함
>- 프로그램을 컴파일하고 메모리에 배치하여 사용 가능한 CPU 코어에서 실행됨
>>1. 소스 파일은 임의의 물리 메모리 위치에 적재되도록 설계된 오브젝트 파일로 컴파일되며 재배치 가능 오브젝트 파일이라고 함
>>2. 링커가 재배치 가능 오브젝트 파일을 하나의 이진 파일로 결합함
>>3. 로더가 이진 실행 파일을 메모리에 적재하며 CPU 코어에서 실행할 수 있는 상태가 됨

<br>

[목차로 이동](#목차)

>### 운영체제의 구조
>- 현재의 운영체제 같이 크고 복잡한 시스템은 적절하게 동작하고 쉽게 변경될 수 있어야 함
>>- 일반적으로 한 개의 일관된 시스템보다는 태스크를 작은 구성요소로 분할함
>>- 구성요소 각각은 신중히 정의된 인터페이스와 기능들을 가진 시스템의 잘 정의된 부분이어야 함
>- 모놀리식 구조
>>- 운영체제를 구성하는 가장 간단한 구조는 모놀리식 구조라고 불리는 커널의 모든 기능을 단일 주소 공간에서 실행되는 단일 정적 이진 파일에 넣는것으로 운영체제를 설계하는 일반적인 기술임
>>- 제한적인 구조를 가진 운영체제의 예는 최초의 UNIX 운영체제로 커널과 시스템 프로그램의 두 부분으로 구성됨
>>>- ![UNIX시스템구조](./imgs/UNIX시스템구조.PNG)
>>>- 커널은 여러 가지 인터페이스와 장치 드라이버로 다시 분리되는데 UNIX가 발전해오면서 추가되고 확장된 것임
>>>- 시스템 콜 인터페이스 아래와 물리적 하드웨어 위의 모든 것이 커널임
>>>>- 커널은 시스템 콜을 통해 파일 시스템, CPU 스케줄링, 메모리 관리 그리고 다른 운영체제 기능을 제공함
>>- Linux는 UNIX에 기반을 두고 있으며 Linux 커널은 단일 주소 공간에서 커널 모드로 전부 실행된다는 점에서 모놀리식이지만 런타임 중에 커널을 수정할 수 있는 모듈식 설계를 갖추고 있음
>>>- ![Linux시스템구조](./imgs/Linux시스템구조.PNG)
>>- 모놀리식 커널은 명백한 단순성에도 불구하고 구현 및 확장하기 어렵지만 모놀리식 커널은 성능 면에서 뚜렷한 이점이 있음
>>>- 시스템 콜 인터페이스에는 오버헤드가 거의 없고 커널 안에서의 통신 속도가 빠름
>>>- 모놀리식 커널의 단점에도 불구하고 속도와 효율성은 이 구조를 여전히 UNIX, Linux 및 Windows 운영체제에서 발견할 수 있는 이유임
>- 계층적 접근
>>- 모놀리식 접근법은 시스템의 한 부분을 변경하면 다른 부분에 광범위한 영향을 줄 수 있어 밀접하게 결합된 시스템으로 불림
>>- 대안으로 느슨하게 결합된 시스템을 설계할 수 있음
>>>- 특정 기능 및 한정된 기능을 가진 개별적 작은 구성요소로 나누고 모든 구성요소가 합쳐지면 커널이 구성됨
>>>- 한 구성요소의 변경이 다른 구성요소에는 영향을 미치지 않으므로 시스템 구현자가 시스템의 내부 작동을 더 자유롭게 생성하고 변경할 수 있음
>>- 시스템은 다양한 방식으로 모듈화 될 수 있으며 그 중 한 가지 방식이 계층적 접근방식임
>>>- 최하위 층(0층)은 하드웨어이고 최상위 층(N층)은 사용자 인터페이스임
>>>- 운영체제 층은 데이터와 이를 조작하는 연산으로 구성된 추상 객체의 구현임
>>>>- 전형적인 운영체제 층(M층)은 자료구조와 상위층에서 호출할 수 있는 루틴의 집합으로 구성됨
>>>>- M층은 하위 층에 대한 연산을 호출할 수 있음
>>- 계층적 접근 방식은 구현과 디버깅이 간단하다는 장점이 있음
>>>- 각 층은 단지 자신보다 하위 층들의 서비스와 기능(연산)들만 사용하여 시스템의 검증과 디버깅 작업을 단순화함
>>>>- 어느 층의 디버깅 중 오류가 발견되며 하위 층들은 이미 디버깅되었기 때문에 오류는 반드시 해당 층에 있음
>>>>- 시스템을 계층으로 나누면 시스템의 설계나 구현이 간단해짐
>>>- 각 층은 자신보다 하위 층에 의해 제공된 연산들만을 사용하여 구현되는데 연산들이 어떻게 구현되는지 알 필요가 없고 연산들이 무엇을 하는지만 알면 됨
>>>- 각 층은 특정 데이터 구조와 연산 그리고 하드웨어의 존재를 상위 층에 대해 숨길 수 있음
>>- 계층화된 시스템은 컴퓨터 네트워크(TCP/IP 등) 및 웹 응용 프로그램에서 성공적으로 사용되었으나 순수한 계층 접근 방식을 사용하는 운영체제는 많지 않음
>>>- 각 계층의 기능을 적절히 정의해야 하는데 문제가 있음
>>>- 시스템의 전반적인 성능은 운영체제 서비스를 얻기 위해 사용자 프로그램이 여러 계층을 통과해야 하는 오버헤드로 인해 열악함
>>- 어느 정도의 계층화는 현대 운영체제에서 공통적임
>>>- 더 많은 기능을 가진 더 적은 개수의 층을 가지므로 층 기능의 정의 및 상호작용의 문제를 피하면서 모듈화된 코드의 장점을 최대한 활용할 수 있음
>- 마이크로커널
>>- 